\chapter{Grundlagen}

\section{Mathe/ ML Learning}

\section{Relationale Datenbanksysteme}
Relationale Datenbanksysteme gehören zu den erfolgreichsten und verbreitetsten Datenbanken, welche zur elektronischen Datenverwaltung in Computersystemen eingesetzt werden\cite{DBLP:books/daglib/0044627}. In diesem Abschnitt werden wichtige Grundbegriffe relationaler Datenbanksysteme erläutert und erklärt, wie Daten repräsentiert und verarbeitet werden können. Die Notation und Bezeichnungen basieren auf Heuer et al. \cite{DBLP:books/daglib/0044627}. Zum Abfragen und Manipulieren der Daten wird die Datenbanksparche SQL eingeführt und deren theoretische Grundlage im Abschnitt \ref{abs:SQL_intro} beleuchtet. Schließlich werden im Abschnitt \ref{abs:SQL_linalg} Methoden vorgestellt, um Objekte der linearen Algebra als Relationen darzustellen und damit verbundene Operationen, beispielsweise die Matrixvektormultiplikation, datenbankgestützt umzusetzen.

\subsection{Das Relationenmodell}
Der Grundbaustein relationaler Datenbanksysteme bildet die Relation. Sie stellt eine mathematische Beschreibung einer Tabelle, welche aus Attributen und zugehörigen Domänen besteht, dar.

\begin{defi}[Universum, Attribut, Domäne]
    \label{def:universum}
    Bezeichne die endliche Menge $\mathcal{U} \neq \emptyset$ das Universum. Ein Element $A \in \mathcal{U}$ heißt Attribut. Für $m \in \mathbb{N}$ sei $\mathcal{D}=\{D_1, \ldots, D_m\}$ eine Menge nichtleere Mengen. Ein Element $D_i \in \mathcal{D}$ wird Domäne genannt. Für eine Funktion $\mathrm{dom}: \mathcal{U} \rightarrow \mathcal{D}$ bezeichne $\mathrm{dom}(A)$ den Wertebereich von $A$ und $w \in \mathrm{dom}(A)$ ein Attributwert.
\end{defi}

Nun können das Relationenschema und zugehörige Begriffe wie Relation und Tupel definiert werden.

\begin{defi}[Relationenschema, Relation, Tupel]
    \label{def:relation}
    Eine Menge $R \subseteq \mathcal{U}$ heißt Relationenschema über dem Universum $\mathcal{U}$. Für $R=\{A_1, \ldots, A_n \}$ ist eine Relation $r$ über $R$, kurz $r(R)$, als eine endliche Menge von Abbildungen
    \begin{equation*}
        t:R \rightarrow \bigcup_{i=1}^m D_i
    \end{equation*}
    definiert. Dabei gilt $t(A) \in \mathrm{dom}(A)$. Die Abbildungen $t$ werden Tupel genannt und mit $t(A)$ ist die Restriktion der Abbildung $t$ auf $A \in R$ gemeint.
\end{defi}

Vereinfacht gesagt, setzt sich eine Datenbank als Menge von Relationen und ein Datenbankschema als Menge der zugehörigen Relationenschemata zusammen.

\begin{defi}[Datenbank, Datenbankschema, vgl.\cite{DBLP:books/daglib/0044627}]
    Für $p \in \mathbb{N}$ ist eine Menge von Relationenschemata $S=\{R_1, \ldots, R_p\}$ als Datenbankschema definiert. Eine Datenbank $d$ über dem Schema $S$, kurz $d(S)$, ist eine Menge von Relationen
    \begin{equation*}
        d=\{r_1, \ldots, r_p \}
    \end{equation*}
    mit $r_i(R_i)$ für $1 \leq i \leq p$. Eine Relation $r \in d$ wird Basisrelation genannt.
\end{defi}

Weiter können Beziehungen zwischen Attributen und Relationen definiert werden. Für diese Arbeit ist der Begriff des Schlüsselattributs wesentlich.

\begin{defi}[Schlüssel]
    Sei $R$ ein Relationenschema und $K=\{B_1, \ldots, B_k\} \subseteq R$. Gilt für jede Relation $r(R)$ die Beziehung
    \begin{equation*}
         \forall t_1, t_2 \in r: \; [ t_1 \neq t_2 \Rightarrow \exists B \in K: \, t_1(B) \neq t_2(B)],
    \end{equation*}
    so wird $K$ identifizierende Attributmenge genannt. Ein Schlüssel ist eine bezüglich der Mengeninklusion $\subset$ minimal identifizierende Attributmenge. Die Attribute eines Schlüssels werden Primattribute genannt.
\end{defi}

Mit diesen Begriffen lässt sich das relationale Datenbanksystem definieren.

\begin{defi}
    Ein relationales Datenbanksystem ist eine Kombination aus Datenbank und Datenbankmanagementsystem, wobei letzteres zur Verwaltung der Daten verwendet wird.
\end{defi}

Das Managementsystem ist als abgekapseltes Softwaremodul zu interpretieren, welches bestimme Funktionen zur Verwaltung der Datenbank unter gewissen Anforderungen liefert. Typischerwiese sind die von Edgar F. Codd etablierten Anforderungspunkte, siehe \cite{DBLP:books/daglib/0044627}, von einem Datenbankmanagementsystem umzusetzen. Eine der geforderten Funktion bildet die Anfrage an eine Datenbank, um Daten auslesen oder manipulieren zu können. Dabei sei bemerkt, dass je nach Datenbanksystem die Anfragebearbeitung unterschiedlich abläuft. Für eine vertiefende Analyse von Architekturen, Funktionalitäten und Implementierungsmöglichkeiten von relationalen Datenbanksystemen sei auf Heuer et. al.\cite{DBLP:books/mitp/HSS19, DBLP:books/daglib/0044627} verwiesen. 

Im Folgenden wird die Relationenalgebra als Anfragesprache vorgestellt. Sie bildet die theoretische Grundlage der weitverbreiteten Anfragesprache SQL, welche im Folgeabschnitt \ref{abs:SQL_intro} im Fokus steht. Zusammen mit der erweiterten Relationalgebra gelingt im Abschnitt \ref{abs:SQL_linalg} die Umsetzung von Basisoperationen der linearen Algebra in SQL.

\subsection{Die Relationenalgebra}
In der Relationenalgebra werden Relationen als abstrakte Datentypen mit darauf definierten Operationen definiert. Eine Anfrage ist eine Komposition von Operatoren aus einem gewissen Operatorensystem. Ein geeignetes System ist $\omega= \{ \pi, \sigma, \bowtie, \cup, \setminus, \beta \}$, welches im Folgenden definiert wird.

\begin{itemize}
    \item Für eine relation $r(R)$ mit Tupeln $t$ wird die Projektion $\pi_X(r)$ auf das Attribut $X \subseteq R$ durch
    \begin{equation*}
        \pi_X(r):=\{t(X) \; | \; t \in r \}
    \end{equation*}
    definiert. 
    \item Die Konstantenselektion $\sigma_{X \theta c}$ ist als
    \begin{equation*}
        \sigma_{X \theta c}(r):=\{t \; | \; t \in r \wedge t(X) \; \theta \; c\}
    \end{equation*}
    definiert.
    Hierbei ist $\theta \in \{=, \neq\}$ möglich und bei Wertebereichen, welche mit einer Halbordnung ausgestattet sind, ist $\theta \in \{\leq, <, \geq, >, = ,\neq\}$ möglich. 
    Bei Attributen mit demselben Wertebereich ist die Attributselektion $\sigma_{X \theta Y}$ für $X, Y \subseteq R$ als
    \begin{equation*}
        \sigma_{X \theta Y}(r):=\{t \; | \; t \in r \wedge t(X) \; \theta \; t(Y)\}
    \end{equation*}    
    definiert. Zudem können mehrere Selektionsbedingungen beliebig logisch mit $\wedge, \vee $ und $\neg$ in $F$ verknüpft werden. Die Selektion $\sigma$ ist eine Konstanten- oder Attributselektion.
    \item Sind $r_1(R_1)$ und $r_2(R_2)$ Relationen, so verbindet der natürliche Verbund $\bowtie$ Tupel der beiden Relationen mit gleichen Attributwerten von gleichnamigen Attributen, also 
    \begin{equation*}
        r_1 \bowtie r_2 := \{t \; | \; t(R_1 \cup R_2) \wedge \exists t_1 \in r_1: t_1=t(R_1) \wedge \exists t_2 \in r_2: t_2=t(R_2)\}.
    \end{equation*} Ist $R_1=R_2$ so wird $\bowtie$ zum mengentheoretischen Durchschnitt und für $R_1 \cap R_2=\emptyset$ ergibt sich das kartesische Produkt von $r_1$ und $r_2$.
    \item Die Vereinigung zweier Relationen $r_1(R)$ und $r_2(R)$ über dem Relationenschema $R$ ist durch
    \begin{equation*}
        r_1 \cup r_2:=\{ t \; | \; t \in r_1 \wedge t \in r_2 \}
    \end{equation*}
    definiert.
    \item Die Differenz zweier Relationen $r_1(R)$ und $r_2(R)$ über dem Relationenschema $R$ ist als
    \begin{equation*}
        r_1 \setminus r_2:=\{ t \; | \; t \in r_1 \wedge t \notin r_2 \}
    \end{equation*}
    definiert.
    \item Die Umbenennung $\beta$ wird für die obigen Operationen benötigt, da diese von der Attributbenennung abhängen. Für $A \in R, B \notin (R \setminus \{A\})$ sei $R':=(R \setminus \{A\}) \cup B$. Die Umbenennung $\beta$ von $A$ zu $B$ in $r(R)$ ist für $\mathrm{dom}(A)=\mathrm{dom}(B)$ als
    \begin{equation*}
        \beta_{B \leftarrow A}:=\{t' \; | \; \exists t \in r: t'(R \setminus \{A\})=t(R \setminus \{A\}) \wedge t'(B)=t(A)\}
    \end{equation*}
    erklärt.
\end{itemize}
Es sei darauf hingewiesen, dass weitere Operatorensysteme existieren, welche zu $\omega$ äquivalent sind\cite{DBLP:books/daglib/0044627}.

\subsection{Die Anfragesprache SQL}

\subsection{Lineare Algebra in SQL}
\label{linalgsql}
In diesem Abschnitt wird eine Darstellungsform von Vektoren und Matrizen als Relationen vorgestellt. Weiter werden Ideen zur Umsetzung wichtiger Basisoperationen mit Vektoren und Matrizen in SQL beleuchtet, da diese mathematischen Objekte bei zahlreichen statistischen Analysen eingestzt werden.
\subsection{Matrixdarstellunng}
Im Folgenden wird das \textit{Coordinate scheme} \cite{martendiss} als Schema für die Darstellung  von Matrizen und Vektoren genutzt. Dieses Schema gestaltet sich als einfach und ist daher weit verbreitet \cite{saad1990sparskit}.
Für eine weiterführende Diskussion anderer Darstellungsmöglichkeiten, sei an dieser Stelle auf Marten \cite{martendiss} verwiesen. 
Das Coordinate Scheme beinhaltet 3 Arrays, welche den Zeilenindex, Spaltenindex und den Matrixeintrag als jeweilge Nicht-Null Werte strukturieren. 
\begin{bsp}
    \label{besipiel:_coordinate_sheme}
    Für $x \in \RR^n$ und $A \in \RR^{n \times m}$ ergeben sich die Relationen
    \begin{align*}
        X( &\underline{i} \; \; \mathrm{int}, \\
        &v \; \; \mathrm{double})
    \end{align*}
    für den Vektor $x$ und
    \begin{align*}
        A( &\underline{i} \; \; \mathrm{int}, \\
        &\underline{j} \; \;\mathrm{int},\\
        &v \; \; \mathrm{double})
    \end{align*} für die Matrix $A$.
    Ist
    \begin{equation*}
        A=\begin{pmatrix}
            1 & 2 \\
            -5 & 2 \\
            0 & 7 \\
        \end{pmatrix}
        \in \RR^{3 \times 2}
    \end{equation*}
    gegeben, so ergibt sich Coordinate Schema wie in Abbildung 2.1.
\end{bsp}

\begin{figure}[h]
    \label{coordinate_scheme_table}
    \centering
    \begin{tabular}{ |c|c|c|c|c|c|c| } 
     \hline
     Zeile $i$ &1 &1 &2 &2 &3 &3 \\ 
     \hline
     Spalte $j$ &1 &2 &1 &2 &1 &2 \\ 
     \hline
     Eintrag $a_{i,j}$ &1 &2 &-5 &2 &0 &7 \\ 
     \hline
    \end{tabular}
    \caption{Das Coordinate Schema zur Matrix $A$ aus Beispiel \ref{besipiel:_coordinate_sheme}.}
\end{figure}



\subsection{Basisoperationen}
\label{abs_basisoperationen}
In diesem Abschnitt werden typische Operationen mit Objekten der linearen Algebra beschrieben. Einfache Operationen wie Summation und Multiplikation für reelle Zahlen sind bereits im SQL-Standard enthalten. Seien nun Vektoren $x,y \in \RR^n$ sowie Matrizen $A,B \in \RR^{m \times n}$ und Skalare $r,s \in \RR$ gegeben. Die SQL-Anweisung für die Vektoraddition $rx+sy$ lautet
\begin{align*}
    & \mathbf{select} \; x.i \; \mathbf{as} \; i, \; r*x.v+(s*y.v ) \; \mathbf{as} \; v \\
    & \mathbf{from} \; x \; \mathbf{join} \; y \; \mathbf{on} \; x.i=y.i
\end{align*}
Ähnlich ergibt sich die Matrixaddition $rA+sB$ zu
\begin{align*}
    & \mathbf{select} \; A.i \; \mathbf{as} \; i, \; A.j \; \mathbf{as} \; j, r*A.v+(s*B.v ) \; \mathbf{as} \; v \\
    & \mathbf{from} \; A \; \mathbf{join} \; B \; \mathbf{on} \; A.i=B.i \; \mathbf{and} \; A.j=B.j
\end{align*}
Das Auftreten von \textbf{NULL}-Werten in den Relationen sei hierbei ausgeschlossen. 
Mit der Aggregation \textbf{SUM} können zudem Skalarprodukte und damit Längenbegriffe wie Normen und dadurch induzierte Abstandsbergiffe formuliert werden. Die entsprechenden SQL-Anfragen  sind im Anhang \ref{app:app_1} zu finden. \\
Weitere wichtige Oprationenen stellen die Matrixvektor- und Matrixmatrixmultiplikation dar. 
Durch Kombination vorheriger Basisoperationen ergeben sich entsprechende Transformationenen für die Matrixvektormultiplikation $Ax \in \RR^m$ einer Matrix $A \in \RR^{m \times n}$ und Vektors $x \in \RR^n$ zu

\begin{align*}
    & \mathbf{select} \; A.i \; \mathbf{as} \; i, \; \mathbf{sum} (A.v*x.v) \; \mathbf{as} \; v\\
    & \mathbf{from} \; A \; \mathbf{join} \; x \; \mathbf{on} \; A.j=x.i \; \\
    & \mathbf{group} \; \mathbf{by} \; A.i
\end{align*}

Für die Matrix $C=AB \in \RR^{m \times n}$ als Produkt zweier Matrizen $A \in \RR^{m \times k}$ und $B \in \RR^{k \times n}$ lautet die Anfrage

\begin{align*}
    & \mathbf{select} \; A.i \; \mathbf{as} \; i, \; B.j \; \mathbf{as} \; j, \; \mathbf{sum} (A.v*B.v) \; \mathbf{as} \; v\\
    & \mathbf{from} \; A \; \mathbf{join} \; B \; \mathbf{on} \; A.j=B.i \; \\
    & \mathbf{group} \; \mathbf{by} \; A.i, \, B.j
\end{align*}
Schließlich kann auch die Transponierte $A^T$ einer Matrix $A$ einfach berechnet werden, siehe dazu Anhang \ref{app:app_1}.

Zusammenfassend stellt sich heraus, dass wesentliche Objekte der linearen Algebra und damit verbundene fundamentale Operationen im SQL-Kern umgesetzt werden können.  
Im folgenden Abschnitt werden diese Resultate genutzt und im Zusammenhang mit einem Machine- Learning-Verfahren eingesetzt.
Problemstellung(Einleitung)

\begin{defi}
    \label{def:image}
    Eine Matrix $X \in [0,1]^{h \times b}$ heißt (Grauwert)-Bild mit der Höhe $h$ und Breite $b$. Mit $X_{i,j}$ wird der Grauwert des Pixels $p=(i,j)$ bezeichnet.
\end{defi}


Training, Aufgabe Leistung

supervisies, unsupervised erklären

Klassifikationsproblem

Merkmalsextraktion( 1FFT 2FFT, IFFT NFFT)

(Faltung)

(FFT Regeln insb convolution/coprrelation theorem mit FFT)

Trennbarkeit linear/nichtlinear Entscheidungsgrenzen Hyperebene

Perzeptron Theorem

numerische Minimierung, kurz Abstiegsverfahren in einfacher Version

falls nötig adaptive Verfahren

warum NN?

warum später CNN?


\section*{SQL}
Relationen, Tensoren

Marizen/Vektoren als Relationen

Basisoperationen

