\chapter{Grundlagen}
\label{kap:fund}
In diesem Kapitel werden grundlegende Begriffe und Definitionen erläutert, die im weiteren Verlauf dieser Arbeit genutzt werden. Zunächst wird im Abschnitt \ref{abs:mathe_intro} ein kurzer Überklick über das Maschinelle Lernen und dessen mathematische Grundlagen gegeben. Weiter wird die Klassifikationsaufgabe definiert und ein erster Lernalgorithmus vorgestellt, welcher im weiteren Verlauf der Arbeit verfeinert wird. Im Hinblick auf die Transformation von ML-Algorithmen in SQL-Anweisungen werden im Abschnitt \ref{abs:relation_intro} relationale Datenbanksysteme und die Anfragesprache SQL eingeführt.
\section{Maschinelles Lernen}
\label{abs:mathe_intro}
Maschinelle Lernverfahren können genutzt werden, um Muster in digitalisierten Objekten zu erkennen. Hier kommen Algorithmen zum Einsatz, welche hinsichtlich einer bestimmten Aufgabe, engl. \textit{task T}, und einem Leistungsmaß, engl. \textit{perfomance P} an der Erfahrung, engl. \textit{experience E} lernen, vgl. \cite{mitchell1997machine}. Dabei ist mit Lernen gemeint, dass das Computerprogramm bezüglich der Aufgabe $T$ sein
Leistungsmaß $P$ mit wachsender Erfahrung $E$ schrittweise steigert. Diese Begriffe werden im Kontext des überwachten Lernens im Folgenden eingeführt.

\subsection{Die Klassifikationsaufgabe}
\label{abs:classtask}
Seien gewisse Objekte $O_1, \ldots, O_m$ durch Vektoren repräsentiert, welche in der Menge $\mathcal{M}:=\{x_i \; : \; 1 \leq i \leq m \}$ gesammelt werden. Jedes der Objekte lässt sich durch die Funktion $f:\mathcal{M} \rightarrow \{K_1, K_2, \ldots, K_s\}$ zu einer der $s$ Klassen zuordnen. Die Funktion $f$ wird Klassifikationsfunktion genannt. Im Allgemeinen ist diese Funktion jedoch unbekannt und es steht nur eine endliche Menge von Tupeln der Form $(x_i, f(x_i))_{i=1}^m$ zur Verfügung. 
\begin{defi}[Trainingsmenge]
    \label{deff:trainset}
    Seien die Mengen $\mathcal{M}$ und $\mathcal{C}:=\{K_1, \ldots, K_s \}$ gegeben. Weiter sei $f: \mathcal{M} \rightarrow \mathcal{C}$ eine (unbekannte) Klassifikationsfunktion. Dann wird die Menge 
    \begin{equation}
        \label{eq:trainset}
        \mathcal{T}:=\{(x_i, f(x_i))\; : \; 1 \leq i \leq m\}
    \end{equation} Trainingsmenge genannt. 
\end{defi}
Nun kann die Klassifikation als \textit{task T} definiert werden, welche im weiteren Verlauf dieser Arbeit im Fokus steht.
\begin{defi}[Klassifikationsaufgabe]
    Seien $\mathcal{M}$ und $\mathcal{C}$ wie in Definition \ref{deff:trainset} gegeben. Die Klassifikationsaufgabe besteht darin, ein Modell $\tilde{f}_{\mathcal{W}}:\mathcal{M} \rightarrow \mathcal{C}$, abhängig von Parametern $\mathcal{W}$, zu entwickeln, welches die Funktion $f$ hinreichend gut approximiert. Zur Vereinfachung der Notation wird das Modell in Zukunft mit $\tilde{f}$ bezeichnet.
\end{defi}
Im Zuge des überwachten Lernens wird eine Trainingsphase durchgeführt, bei welcher die Modellparameter $\mathcal{W}$ mithilfe der Trainingsmenge $\mathcal{T}$ (\ref{eq:trainset}) in einem iterativen Prozess schrittweise angepasst werden. Die Tupel in $\mathcal{T}$, welche die gewünschten Ausgaben beinhalten, können als \textit{experience E} interpretiert werden.
Die Güte der Approximation $\tilde{f}$ wird durch Fehlerfunktionen gemessen. Ziel ist es, die \textit{performance P} des Modells durch die Minimierung solcher Fehlerfunktionen zu steigern.  
\begin{defi}
    Seien eine Klassifikationsfunktion $f$, eine Trainingsmenge $\mathcal{T}$ und Modellparameter $\mathcal{W}$ gegeben. Für das Modell $\tilde{f}$ soll das Minimierungsproblem 
    \begin{equation}
        \label{eq:opt_fund_abs}
        \mathcal{E}(\mathcal{T}, \mathcal{W}):=\sum_{i=1}^m \; \mathcal{E}(\tilde{f}(x_i),f(x_i)) \rightarrow \min
    \end{equation}
    durch die Anpassung der Modellparameter $\mathcal{W}$ gelöst werden. Dabei wird $\mathcal{E}$ Fehlerfunktion genannt. Diese sei in dieser Arbeit als stetig differenzierbar vorausgesetzt.
\end{defi}
Bei neuronalen Netzen wird das Optimierungsproblem (\ref{eq:opt_fund_abs}) mithilfe des Backpropagationsalgorithmus bearbeitet. Jener wird im Hinblick auf Problem \ref{prop:train} in den Kapiteln \ref{kap:NN} und \ref{kap:CNN} für die dort verwendeten Modelle ausführlich vorgestellt. 

In der Praxis werden Testdaten, für die die Klassenzugehörigkeiten bekannt sind, genutzt, um die Generalisierungsfähigkeit des Modells zu messen. Diese Daten werden während des Trainingsprozesses zur Anpassung der Modellparameter $\mathcal{W}$ nicht benutzt.

\begin{defi}[Testmenge]
    Seien die Datenmenge $\mathcal{M}':=\{x_i \; : \; 1 \leq i \leq m'\}$ und die Menge $\mathcal{C}:=\{K_1, \ldots, K_s \}$ der Klassen gegeben. Weiter sei $f: \mathcal{M}' \rightarrow \mathcal{C}$ eine bekannte Klassifikationsfunktion. Dann wird mit 
    \begin{equation}
        \label{eq:testset}
        \mathcal{T}':=\{(x_i, f(x_i))\; : \, 1 \leq i \leq m'\}
    \end{equation}
    eine Testmenge bezeichnet.
\end{defi}
Auf Trainings- bzw. Testmengen lassen sich Fehlerraten als Perfomance-Maße definieren.

\begin{defi}[Erkennungsrate, Generalisierungsrate]
    Sei die Approximation $\tilde{f}$ gegeben.
    Die Erkennungsrate von $\tilde{f}$ ergibt sich durch den Anteil der richtig klassifizierten Lerndaten in der Trainingsmenge. Die Generalisierungsrate von $\tilde{f}$ ist durch den Anteil der richtig klassifizierten Lerndaten in der Testmenge gegeben.
\end{defi}

Schließlich ist noch das Problem der Überanpassung, engl. \textit{overfitting}, zu erwähnen. Dieses Phänomen tritt auf, wenn die Erkennungsrate eines verwendeten Modells $\tilde{f}$ während der Trainingsphase weiter steigt, gleichzeitig aber die Generalisierungsrate sinkt. In diesem Fall passt sich das Modell an zufälliges Rauschen in den Trainingsdaten an und ist für die Klassifikation allgemeiner Daten meist unbrauchbar. Für eine vertiefende Analyse des Overfittings und anderer Probleme sowie deren Behandlung sei auf Goodfellow \cite{Goodfellow-et-al-2016} verwiesen.
Fraglich bleibt zudem, unter welchen Voraussetzungen überhaupt eine sinnvolle Approximation möglich ist. Dazu wird im Folgenden das Problem der linearen Trennbarkeit von Punktmengen behandelt.
\subsection{Trennbarkeit und ein erster Lernalgorithmus}
\label{abs:trenn}
Seien wieder Vektoren $x_1, \ldots, x_m \in \RR^{n}$ aus Objekten $O_1, \ldots, O_m$ extrahiert. Zunächst wird der einfache Fall betrachtet, bei dem die Punkte $x_i$ jeweils zu genau einer der zwei Klassen $K_0$ und $K_{1}$ zugeordnet sind. Seien dazu die Punktmengen
\begin{align*}
    \mathcal{M} & :=\{x_i \; : \; 1 \leq i \leq m\} \subseteq \RR^{n}, \\
    \mathcal{M}_i &:=\{x_l \; : \; O_l \; \text{gehört zur Klasse} \; K_i\}, \; \, i=0,1
\end{align*}
definiert.

\begin{defi}
    Zwei Punktmengen $P_0, P_{1} \subseteq \RR^n$ heißen linear trennbar genau dann, wenn Parameter $w \in \RR^n$ und $\theta \in \RR^n$ existieren, sodass
    \begin{equation*}
        w^T x - \theta \begin{cases}
            <0, \; x \in \mathcal{M}_{0} \\
            \geq 0, \; x \in \mathcal{M}_1
        \end{cases}
    \end{equation*}
    gilt. Dabei wird $w^T x- \theta=0$ als trennende Hyperebene bezeichnet. Oft wird auch von einer linearen Entscheidungsgrenze gesprochen.
\end{defi}
Sind $w$ und $\theta$ bekannt, so kann die Zugehörigkeit eines Objektes $O_i$ leicht bestimmt werden. Dazu wird $d:=w^T x -\theta$ berechnet. Ist $d<0$, so gehört das Objekt $O_i$ zur Klasse $K_0$, andernfalls zur Klasse $K_1$. Seien 
\begin{equation*}
    \chi(x):= \begin{cases}
        -1,  &x \in \mathcal{M}_0 \\
        1,  &x \in \mathcal{M}_1
    \end{cases}
\end{equation*}
und \begin{equation*}
    w:= \begin{pmatrix}
    w \\
    \theta    
    \end{pmatrix}, \; \; x:=\begin{pmatrix}
        x \\
        -1
    \end{pmatrix} 
\end{equation*}
definiert.
Der sogenannte Perzeptron-Lernalgorithmus \cite{rosenblatt1958perceptron}, kurz PLA, kann genutzt werden, um den Parameter $w$ schrittweise zu bestimmen. Dieser ist algorithmisch in \ref{alg:pla} darstellt. Verändert sich in einem Zyklus, also das einmalige Durchlaufen aller Punkte in $\mathcal{M}$, der Parameter $w$ nicht, so wird der PLA abgebrochen.

\begin{satz}
    Sind $\mathcal{M}_0$ und $\mathcal{M}_1$ linear trennbar, so bricht der Perzeptron-Lernalgorithmus in endlich vielen Schritten ab.
\end{satz}
\begin{proof}
    Ein Beweis kann in Rosenblatt \cite{rosenblatt1958perceptron} gelesen werden.
\end{proof}

\begin{algorithm}[h]
    \caption{Der Perzeptron-Lernalgorithmus}\label{alg:pla}
    \begin{algorithmic}
    \Require Punktmenge $\mathcal{M} \subseteq \RR^n$ 
    \Ensure $w, \theta$ zur Trennung der Punktmengen $\mathcal{M}_{0}$ und $\mathcal{M}_1$ 
    \State Wähle $w=w_0$ beliebig
    \While{Abbruchbedingung nicht erfüllt} \Comment{Abbruchbedingung, siehe Text}
        \For{$i=1, \ldots m}$
            \State $d=\chi(x) w^T x$
            \If{$d \leq 0$}
                \State $w=w+\chi(x) x$
            \EndIf
        \EndFor
    \EndWhile
    \end{algorithmic}
\end{algorithm}

Es lassen sich jedoch einfache Beispiele angeben, bei denen die Punktmengen nicht durch lineare Entscheidungsgrenzen getrennt werden können. Ein Beispiel ist das zweidimensionale XOR-Problem, bei dem die beiden Punktmengen $P_0=\{(0,0), (1,1)\}$ und $P_1=\{(0,1), (1,0) \}$ getrennt werden sollen. Hier scheitert der PLA, da die Punktmengen $P_0$ und $P_1$ nicht linear trennbar sind. Um solche Aufgaben zu lösen, ist es notwendig, komplexe Entscheidungsgrenzen zu ermitteln.

Perzeptronen und neuronale Netze, welche im Kapitel \ref{kap:NN} vorgestellt werden, sind in der Lage, solche Entscheidungsgrenzen auch bei Multiklassenproblemen, also $s \geq 2$, widerzuspiegeln. Um das Problem (\ref{eq:opt_fund_abs}) zu lösen, wird hier die numerische Minimierung von stetig differenzierbaren Funktionen benötigt. Dazu wird das allgemeine Abstiegs-Verfahren genutzt, welches in der Literatur auch Gradientenverfahren genannt wird.

\begin{defi}[Abstiegsrichtung]
    Sei $f:\RR^n \rightarrow \RR$ stetig differenzierbar. Dann heißt $z \in \RR^n$ Abstiegsrichtung für $f$ im Punkt $x \in \RR^n$ genau dann, wenn
    \begin{equation*}
        z^T \nabla f(x) <0
    \end{equation*}
    gilt. 
\end{defi}
Ziel des Verfahrens ist, für eine Funktion $f$ stationäre Punkte $x^*$ mit $\nabla f(x^*)=0$ näherungsweise zu bestimmen. Es werden also Punkte berechnet, welche die notwendige Bedingung einer lokalen Minimalstelle erfüllen.
Aus folgendem Lemma ergibt sich das Gradientenverfahren, siehe Algorithmus \ref{alg:gradver}. 
\begin{lem}
    \label{abst_dir}
    Sei $f:\RR^n \rightarrow \RR$ stetig differenzierbar und $z$ eine Abstiegsrichtung für $f$ im Punkt $x$. Dann existiert ein $\lambda_0$, sodass 
    \begin{equation*}
        f(x+\lambda z) < f(x), \; \; \forall \lambda \in (0, \lambda_0]
    \end{equation*}
    gilt. Die reelle Zahl $\lambda$ wird als Schrittweite bezeichnet.
\end{lem}

\begin{proof}
    Ein Beweis wird in \cite{nocedal1999numerical} vorgeführt.
\end{proof}

\begin{algorithm}[h]
    \caption{Das allgemeine Gradientenverfahren}\label{alg:gradver}
    \begin{algorithmic}
    \Require $f$ stetig differenzierbar, Fehlertoleranz $\varepsilon$, Schrittweite $\lambda$ 
    \Ensure stationärer Punkt $x$
    \State Wähle Startwert $x$ beliebig
    \While{$||\nabla f(x)|| > \varepsilon$} 
        \State Bestimme Abstiegsrichtung $z$ für $f$ in $x$
        \State Setze $x=x+ \lambda z$
    \EndWhile
    \end{algorithmic}
\end{algorithm}

Für eine vertiefende Analyse von Architekturen, Funktionalitäten und Implementierungsmöglichkeiten des Maschinellen Lernens sei auf das umfangreiche Buch von Goodfellow \cite{Goodfellow-et-al-2016} verwiesen.

\section{Relationale Datenbanksysteme}
\label{abs:relation_intro}
Relationale Datenbanksysteme gehören zu den erfolgreichsten und verbreitetsten Datenbanken, welche zur elektronischen Datenverwaltung in Computersystemen eingesetzt werden. In diesem Abschnitt werden wichtige Grundbegriffe relationaler Datenbanksysteme erläutert und erklärt, wie Daten in Relationen repräsentiert und verarbeitet werden können. Die Notation und Bezeichnungen basieren auf Heuer et al.\cite{DBLP:books/daglib/0044627}. Zum Abfragen von Datenbeständen wird die Datenbanksprache SQL im Abschnitt \ref{abs:SQL_intro} eingeführt und deren theoretische Grundlagen im Abschnitt \ref{abs:rela_algebra} beleuchtet. Schließlich werden im Abschnitt \ref{abs:SQL_linalg} Methoden vorgestellt, um Objekte der linearen Algebra als Relationen darzustellen und damit verbundene Operationen, beispielsweise die Matrixvektormultiplikation, datenbankgestützt umzusetzen.

\subsection{Das Relationenmodell}
Der Grundbaustein relationaler Datenbanksysteme bildet die Relation. Sie stellt eine mathematische Beschreibung einer Tabelle, welche aus Attributen und zugehörigen Domänen besteht, dar.

\begin{defi}[Universum, Attribut, Domäne]
    \label{def:universum}
    Bezeichne die endliche Menge $\mathcal{U} \neq \emptyset$ das Universum. Ein Element $A \in \mathcal{U}$ heißt Attribut. Für $m \in \mathbb{N}$ sei $\mathcal{D}=\{D_1, \ldots, D_m\}$ eine Menge nichtleerer Mengen. Ein Element $D_i \in \mathcal{D}$ wird Domäne genannt. Für eine Funktion $\mathrm{dom}: \mathcal{U} \rightarrow \mathcal{D}$ bezeichne $\mathrm{dom}(A)$ den Wertebereich von $A$ und $w \in \mathrm{dom}(A)$ einen Attributwert.
\end{defi}

Nun können das Relationenschema und zugehörige Begriffe wie Relation und Tupel definiert werden.

\begin{defi}[Relationenschema, Relation, Tupel]
    \label{def:relation}
    Eine Menge $R \subseteq \mathcal{U}$ heißt Relationenschema über dem Universum $\mathcal{U}$. Für $R=\{A_1, \ldots, A_n \}$ ist eine Relation $r$ über $R$, kurz $r(R)$, als eine endliche Menge von Abbildungen
    \begin{equation*}
        t:R \rightarrow \bigcup_{i=1}^m D_i
    \end{equation*}
    definiert. Dabei gilt $t(A) \in \mathrm{dom}(A)$. Die Abbildungen $t$ werden Tupel genannt und mit $t(A)$ ist die Restriktion der Abbildung $t$ auf $A \in R$ gemeint.
\end{defi}

Vereinfacht gesagt, setzt sich eine Datenbank als Menge von Relationen und ein Datenbankschema als Menge der zugehörigen Relationenschemata zusammen.

\begin{defi}[Datenbank, Datenbankschema, vgl.\cite{DBLP:books/daglib/0044627}]
    Für $p \in \mathbb{N}$ ist eine Menge von Relationenschemata $S=\{R_1, \ldots, R_p\}$ als Datenbankschema definiert. Eine Datenbank $d$ über dem Schema $S$, kurz $d(S)$, ist eine Menge von Relationen
    \begin{equation*}
        d=\{r_1, \ldots, r_p \}
    \end{equation*}
    mit $r_i(R_i)$ für $1 \leq i \leq p$. Eine Relation $r \in d$ wird Basisrelation genannt.
\end{defi}

Weiter können Beziehungen zwischen Attributen und Relationen definiert werden. Für diese Arbeit ist der Begriff des Schlüsselattributs wesentlich.

\begin{defi}[Schlüssel]
    \label{def:key}
    Sei $R$ ein Relationenschema und $K=\{B_1, \ldots, B_k\} \subseteq R$. Gilt für jede Relation $r(R)$ die Beziehung
    \begin{equation*}
         \forall t_1, t_2 \in r: \; [ t_1 \neq t_2 \Rightarrow \exists B \in K: \, t_1(B) \neq t_2(B)],
    \end{equation*}
    so wird $K$ identifizierende Attributmenge genannt. Ein Schlüssel ist eine bezüglich der Mengeninklusion $\subset$ minimal identifizierende Attributmenge. Die Attribute eines Schlüssels werden Primattribute genannt.
\end{defi}

Mit diesen Begriffen lässt sich das relationale Datenbanksystem definieren.

\begin{defi}
    Ein relationales Datenbanksystem ist eine Kombination aus Datenbank und Datenbankmanagementsystem, wobei letzteres zur Verwaltung der Daten verwendet wird.
\end{defi}

Das Managementsystem ist als abgekapseltes Softwaremodul zu interpretieren, welches bestimmte Funktionen zur Verwaltung der Datenbank unter gewissen Anforderungen liefert. Typischerwiese sind die von Edgar F. Codd etablierten Anforderungspunkte, siehe \cite{DBLP:books/daglib/0044627}, von einem Datenbankmanagementsystem umzusetzen. Eine der geforderten Funktionen bildet die Anfrage an eine Datenbank, um Daten auslesen zu können. Dabei sei bemerkt, dass je nach Datenbanksystem die Anfragebearbeitung unterschiedlich abläuft. Für eine vertiefende Analyse von Architekturen, Funktionalitäten und Implementierungsmöglichkeiten von relationalen Datenbanksystemen sei auf Heuer et. al.\cite{DBLP:books/mitp/HSS19, DBLP:books/daglib/0044627} verwiesen. 

Im Folgenden wird die Relationenalgebra als Anfragesprache vorgestellt. Sie bildet die theoretische Grundlage der weitverbreiteten Anfragesprache SQL, welche im Folgeabschnitt \ref{abs:SQL_intro} im Fokus steht. Zusammen mit der erweiterten Relationenalgebra gelingt im Abschnitt \ref{abs:SQL_linalg} die Umsetzung von Basisoperationen der linearen Algebra in SQL.

\subsection{Die Relationenalgebra}
\label{abs:rela_algebra}
In der Relationenalgebra werden Relationen als abstrakte Datentypen mit darauf definierten Operationen definiert. Eine Anfrage ist eine Komposition von Operatoren aus einem gewissen Operatorensystem. Ein geeignetes System ist $\omega= \{ \pi, \sigma, \bowtie, \cup, \setminus, \beta \}$, welches im Folgenden definiert wird.

\begin{itemize}
    \item Für eine Relation $r(R)$ mit Tupeln $t$ wird die Projektion $\pi_X(r)$ auf das Attribut $X \subseteq R$ durch
    \begin{equation*}
        \pi_X(r):=\{t(X) \; | \; t \in r \}
    \end{equation*}
    definiert. 
    \item Die Konstantenselektion $\sigma_{X \theta c}$ ist als
    \begin{equation*}
        \sigma_{X \theta c}(r):=\{t \; | \; t \in r \wedge t(X) \; \theta \; c\}
    \end{equation*}
    definiert.
    Hierbei ist $\theta \in \{=, \neq\}$ möglich und bei Wertebereichen, welche mit einer Halbordnung ausgestattet sind, ist $\theta \in \{\leq, <, \geq, >, = ,\neq\}$ möglich. 
    Bei Attributen mit demselben Wertebereich ist die Attributselektion $\sigma_{X \theta Y}$ für $X, Y \subseteq R$ als
    \begin{equation*}
        \sigma_{X \theta Y}(r):=\{t \; | \; t \in r \wedge t(X) \; \theta \; t(Y)\}
    \end{equation*}    
    definiert. Zudem können mehrere Selektionsbedingungen beliebig logisch mit $\wedge, \vee $ und $\neg$ in $F$ verknüpft werden. Die Selektion $\sigma$ ist eine Konstanten- oder Attributselektion.
    \item Sind $r_1(R_1)$ und $r_2(R_2)$ Relationen, so verbindet der natürliche Verbund $\bowtie$ Tupel der beiden Relationen mit gleichen Attributwerten von gleichnamigen Attributen, also 
    \begin{equation*}
        r_1 \bowtie r_2 := \{t \; | \; t(R_1 \cup R_2) \wedge \exists t_1 \in r_1: t_1=t(R_1) \wedge \exists t_2 \in r_2: t_2=t(R_2)\}.
    \end{equation*} Ist $R_1=R_2$ so wird $\bowtie$ zum mengentheoretischen Durchschnitt und für $R_1 \cap R_2=\emptyset$ ergibt sich das kartesische Produkt von $r_1$ und $r_2$.
    \item Die Vereinigung zweier Relationen $r_1(R)$ und $r_2(R)$ über dem Relationenschema $R$ ist durch
    \begin{equation*}
        r_1 \cup r_2:=\{ t \; | \; t \in r_1 \vee t \in r_2 \}
    \end{equation*}
    definiert.
    \item Die Differenz zweier Relationen $r_1(R)$ und $r_2(R)$ über dem Relationenschema $R$ ist als
    \begin{equation*}
        r_1 \setminus r_2:=\{ t \; | \; t \in r_1 \wedge t \notin r_2 \}
    \end{equation*}
    definiert.
    \item Die Umbenennung $\beta$ wird für die obigen Operationen benötigt, da diese von der Attributbenennung abhängen. Für $A \in R, B \notin (R \setminus \{A\})$ sei $R':=(R \setminus \{A\}) \cup B$. Die Umbenennung $\beta$ von $A$ zu $B$ in $r(R)$ ist für $\mathrm{dom}(A)=\mathrm{dom}(B)$ als
    \begin{equation*}
        \beta_{B \leftarrow A}:=\{t' \; | \; \exists t \in r: t'(R \setminus \{A\})=t(R \setminus \{A\}) \wedge t'(B)=t(A)\}
    \end{equation*}
    erklärt.
\end{itemize}
Es sei darauf hingewiesen, dass weitere Operatorensysteme existieren, welche zu $\omega$ äquivalent sind\cite{DBLP:books/daglib/0044627}.

\subsection*{Erweiterung der Relationenalgebra}

Mit dem Operatorensystem $\omega$ von oben sind noch keine arithmetischen Berechnungen über Attribute möglich, welche jedoch zwingend für die Umsetzung linearer Algebra benötigt werden. Daher wird im Folgenden die Relationenalgebra aus Abschnitt \ref{abs:rela_algebra} erweitert. In dieser Arbeit wird oft die Gruppierung von Tupeln bezüglich gleicher Attributwertkombinationen benötigt und daher ein Gruppierungsoperator $\gamma$ eingeführt. Darüber hinaus wird die Projektion $\pi$ erweitert, um tupelweise Funktionen, z.B. die Summierung \textbf{SUM}, aus Attributen verwenden zu können.
Dazu werden die bisher eingeführten Operatoren leicht modifiziert, indem sie auf Multimengen definiert werden. Dafür sei an dieser Stelle auf \cite{DBLP:books/daglib/0020812} verwiesen, um die angepasste Definition des Operatorensystems $ \omega$ und die zugrunde liegende Theorie nachzuvollziehen.
\subsubsection*{Der Gruppierungsoperator $\gamma$}
Der Operator $\gamma_L(r)$ dient zur Aggregation von Attributwerten in Gruppen für eine gegebene Relation $r$. Die Liste $L$ kann aus Attributen der Relation $r$ oder aus bestimmten Aggregatfunktionen bestehen, welche auf den jeweiligen Attributen berechnet werden. Die Ergebnisrelation besteht aus Tupeln von $r$, welche in Gruppen partitioniert sind. Dabei ergeben sich die jeweiligen Gruppen durch gleiche Attributwertkombinationen der Gruppierungsattribute in $L$. Es wird für jede Gruppe ein Tupel berechnet, welches dann aus den Attributwerten der Attribute aus $L$ oder den Ergebnissen der Aggregatfunktionen aus $L$ besteht. Folgendes Beispiel illustriert die Funktionsweise des Gruppierungsoperator $\gamma$. Dazu sei die Relation \textbf{A} in Tabellenform \ref{tab:bsp_group} gegeben.
\begin{table}[h]
    \centering
    \begin{tabular}{|c|c|c|} \hline
        \multicolumn{3}{|c|}{\textbf{A}} \\ \hline
        \hline
        i &j &v\\
        \hline
        1 &1 &3\\
        \hline
        1 &2 &1\\
        \hline
        2 &1 &4\\
        \hline
        2 &2 &1\\
        \hline
    \end{tabular}
    \caption[]{Zu sehen ist die Beispielrelation \textbf{A} bestehend aus den Attributen $i, j$ und $v$.}
    \label{tab:bsp_group}
\end{table}
Die Relation \textbf{A} kann als Matrix 
\begin{equation*}
    A=\begin{pmatrix}
        3 &1\\
        4 &1
    \end{pmatrix}
\end{equation*}
interpretiert werden. Weitere Ausführungen dazu werden im späteren Abschnitt \ref{abs:SQL_linalg} vorgestellt. Die Spaltensumme von $A$ kann mit der Gruppierungsoperation
\begin{equation*}
    \gamma_{j, \; \mathbf{SUM}(v) \rightarrow v}(\mathbf{A}) \Rightarrow 
    \begin{tabular}{|c|c|} \hline
        j &v\\
        \hline
        1 &7\\
        \hline
        2 &2\\
        \hline
    \end{tabular}
\end{equation*} 
berechnet werden. Mit dem Pfeil ist die Umbenennung $\beta$ gemeint.

\subsubsection*{Der erweiterte Projektionsoperator}
Des Weiteren soll der Projektionsoperator $\pi_F(r)$ auf tupelweise arithmetische Berechnungen bezüglich einer oder mehrerer Attribute einer Relation $\mathbf{r}$ erweitert werden. Dazu wird wieder eine Liste $F$ genutzt, welche 
\begin{itemize}
    \item Attribute der Relation $r$,
    \item Umbenennungen der Form $x \rightarrow y$, wobei $x$ ein Attribut der Relation $r$ ist, oder
    \item Ausdrücke der Form $E \rightarrow z$, wobei $E$ aus Attributen der Relation $r$, Konstanten oder arithmetischen Operationen besteht,
\end{itemize}
beinhalten kann. Die Funktionsweise des erweiterten Projektionsoperators wird an der Beispielrelation \ref{tab:bsp_group} beleuchtet. Die Matrixaddition
\begin{equation*}
    2 \cdot A + \begin{pmatrix}
        1 & 1\\
        1 &1
    \end{pmatrix}
\end{equation*}
lässt sich durch
\begin{equation*}
    \pi_{i,\; j, \; 2*v+1 \rightarrow v}(\mathbf{A}) \Rightarrow
    \begin{tabular}{|c|c|c|} \hline
        i &j &v\\
        \hline
        1 &1 &7\\
        \hline
        1 &2 &3\\
        \hline
        2 &1 &9\\
        \hline
        2 &2 &3\\
        \hline
    \end{tabular}
\end{equation*}
berechnen. Für diese Arbeit genügt die erweiterte Relationenalgebra mit der Gruppierung $\gamma_L$ und der erweiterten Projektion $\pi_F$, um fundamentale Operationen der linearen Algebra in der Datenbanksprache SQL darzustellen. Diese wird im folgenden Abschnitt vorgestellt.
\subsection{Die Anfragesprache SQL}
\label{abs:SQL_intro}
SQL als Abkürzung für \textit{Structured Query Language} ist eine Datenbanksprache zur Definition von Datenstrukturen in relationalen Datenbanksystemen. Sie wird genutzt, um Datenbestände zu bearbeiten und abzufragen und basiert dabei auf der im vorherigen Abschnitt eingeführten Relationenalgebra. SQL wird als standardisierte Sprache in allen kommerziellen und frei zugänglichen Datenbankmanagementsystemen unterstützt. Da die Sprache unter Mitwirkung von Normungsgremien wie des \textit{American National Standard Institute} (ANSI) und der \textit{International Organization for Standardization} (ISO) seit 1986 standardisiert ist, ist es möglich, über die Grenzen spezieller Systeme hinaus SQL als einheitliche Datenbanksprache zu benutzen. Für eine detailliertere Darstellung der einzelnen Standards sei auf die entsprechende Literatur verwiesen. Ein guter Überblick ist in Heuer et. al.\cite{DBLP:books/daglib/0044627} zu finden.

SQL ist aus mehreren Teilsprachen aufgebaut, welche jeweils unterschiedliche Aufgaben des Datenbankmanagementsystems hinsichtlich der Datendefinition, Dateiorganisation und Anfragebearbeitung übernehmen. Um Methoden der linearen Algebra in Sequenzen von SQL-Anfragen darzustellen, wird der Anfrageteil \textit{Interactive Query Language}, kurz IQL, als deklarative Programmiersprache im Folgenden beleuchtet. Diese bildet das Fundament der Datenselektion und wird zur Analyse von Daten in relationalen Systemen genutzt. Eine Anfrage hat die Form 

\begin{align}
    \label{anf:stand}
    \begin{split}
    & \mathbf{SELECT} \; \text{Projektionsliste }\\
    & \mathbf{FROM} \; \text{Relationenliste } \\
    & [\mathbf{WHERE} \; \text{Bedingung}].
\end{split}
\end{align}
Das Resultat einer Anfrage ist wieder eine Relation. Daher ist es möglich, verschachtelte Anfragen zu formulieren. Die \textbf{SELECT}-Anweisung gibt durch die Attribute in der Projektionsliste das Schema der Ergebnistabelle vor. Die \textbf{FROM}-Klausel beinhaltet die Relationenliste, in welcher die Relationen aufgeführt sind, aus denen Attribute selektiert werden sollen. Die Liste kann aus einer oder aus mehreren Unteranfragen bestehen, welche optional durch Operationen wie dem natürlichen Verbund oder dem kartesischen Produkt kombiniert werden können. Ebenfalls optional ist die \textbf{WHERE}-Klausel, welche Selektionsbedingungen bezüglich Konstanten oder Attributen enthält. 

Um den Anfragemechanismus nachzuvollziehen, seien im Folgenden zwei Relationen \textit{Angestellte} und \textit{Projekt} wie in den Tabellen \ref{abb:angestellte} und \ref{abb:projekt} gegeben.
\begin{table}[h]
    \centering
\begin{tabular}{|c|c|c|c|c|} \hline
    \multicolumn{5}{|c|}{\textbf{Angestellte}} \\ \hline
    \hline
    ID &Name &Spezialisierung &Projektnummer &Gehalt\\ 
    \hline
    1 &Martin &Elektrotechnik &3 &2300\\ 
    \hline
    2 &Lennardt &Informatik &1 &1500\\
    \hline
    3 &Johann &Informatik &3 &1800\\
    \hline
    4 &Anna &Buchhaltung &3 &2000\\
    \hline
    5 &Antonia &Buchhaltung &2 &2000\\ 
    \hline
\end{tabular}
\caption{Abgebildet ist die Beispielrelation Angestellte mit den Attributen ID, Name, Spezialisierung, Projektnummer und Gehalt.}
\label{abb:angestellte}
\end{table}
\begin{table}[H]
    \centering
\begin{tabular}{|c|c|c|c|c|} \hline
    \multicolumn{5}{|c|}{\textbf{Projekt}} \\ \hline
    \hline
    Projektnummer &Projektname &Budget &Ort &Status\\ 
    \hline
    1 &Datenbank 2.0 &50000 &Rostock &abgeschlossen\\ 
    \hline
    2 &Verwaltung &25000 &Rostock &offen\\
    \hline
    3 &Forschungsabteilung  &40000 &Schwerin &offen\\ 
    \hline
\end{tabular}
\caption{Abgebildet ist die Beispielrelation Projekt mit den Attributen Projektnummer, Projektname, Budget, Ort und Status.}
\label{abb:projekt}
\end{table}

Die Anfrage 
\begin{align}
    \label{anf:bsp}
    \begin{split}
    & \mathbf{SELECT} \; \text{A.Name, P.Projektname}\\
    & \mathbf{FROM} \; \text{Angestellte A} \; \mathbf{JOIN} \; \text{Projekt P} \; \mathbf{ON} \; \text{A.Projektnummer} = \text{P.Projektnummer}\\
    &\mathbf{WHERE} \; \text{P.Status}=\text{'offen'}
\end{split}
\end{align}
liefert die Namen der Angestellten von offenen Projekten. Dementsprechend ist die Ergebnisrelation in Tabelle \ref{abb:result_relation} dargestellt.
\begin{table}[H]
    \centering
\begin{tabular}{|c|c|} \hline
    \multicolumn{2}{|c|}{\textbf{Ergebnis}} \\ \hline
    \hline
    A.Name & P.Projektname \\ 
    \hline
    Martin &Forschungsabteilung \\ 
    \hline
    Johann &Forschungsabteilung\\
    \hline
    Anna &Forschungsabteilung\\ 
    \hline
    Antonia &Verwaltung \\
    \hline
\end{tabular}
\caption[]{Zu sehen ist die Ergebnisrelation der zuvor beschriebenen Anfrage (\ref{anf:bsp}).}
\label{abb:result_relation}
\end{table}
Die Aliasnamen \glqq A\grqq{} und \glqq P\grqq{} dienen hier zur Übersicht. Die klassische Anfrage (\ref{anf:stand}) kann mit arithmetischen Operationen und Aggregatfunktionen sowie Gruppierungsfunktionen erweitert werden. Die Funktion \textbf{SUM} kann zur Summierung numerischer Attributwerte eines Attributs über mehrere Tupel verwendet werden. Die \textbf{GROUP BY}-Klausel dient zur Gruppierung von Tupeln bezüglich gleicher Attributwertkombinationen. Eine Kombination aus der Aggregatfunktion \textbf{SUM} und der Gruppierung wird beispielsweise in der Anfrage
\begin{align}
    \label{anf:erw}
    \begin{split}
        & \mathbf{SELECT} \; \text{A.Spezialisierung}, \; \mathbf{SUM}(\text{A.Gehalt}) \; \mathbf{AS} \; \text{Angestelltenkosten}\\
        & \mathbf{FROM} \; \text{Angestellte A} \\
        &\mathbf{GROUP} \, \mathbf{BY} \; \text{A.Spezialisierung}
    \end{split}
\end{align}
verwendet. Diese berechnet die Angestelltenkosten und gruppiert sie nach den jeweiligen Spezialisierungen. Die Ergebnistabelle ist in Tabelle \ref{abb:erg_erw} dargestellt.
\begin{table}[h]
    \centering
\begin{tabular}{|c|c|} \hline
    \multicolumn{2}{|c|}{\textbf{Ergebnis}} \\ \hline
    \hline
    A.Spezialisierung &Angestelltenkosten\\ 
    \hline
    Elektrotechnik &2300 \\ 
    \hline
    Informatik &3300\\
    \hline
    Buchhaltung &4000\\ 
    \hline
\end{tabular}
\caption[]{Es ist die Ergebnisrelation der zuvor beschriebenen Anfrage (\ref{anf:erw})
\label{abb:erg_erw} abgebildet.}
\end{table}
Ein Beispiel einer geschalteten Anfrage zur Bestimmung des Angestellten mit dem höchsten Gehalt ist durch
\begin{align}
    \label{anf:schachtel}
    \begin{split}
        & \mathbf{SELECT} \; \text{A.Name}\;  \mathbf{AS} \; \text{Topverdiener},\; \text{A.Gehalt}\\
        & \mathbf{FROM} \; \text{Angestellte A} \\
        &\mathbf{WHERE} \; \text{A.Gehalt}=(\mathbf{SELECT}\; \mathbf{MAX}(\text{Gehalt}) \; \mathbf{FROM}\; \text{Angestellte})
    \end{split}
\end{align}
gegeben. Dabei wird die Aggregatfunktion \textbf{MAX} verwendet. Die Ergebnisrelation beinhaltet in diesem Beispiel ein Tupel mit Martin als Topverdiener mit einem Gehalt von 2300 Euro.

Weitere Operationen der Relationenalgebra wie die Vereinigung (\textbf{UNION}) und die Mengendifferenz (\textbf{EXCEPT}) können ebenfalls in SQL-Anfragen eingebunden werden. Es sei bemerkt, dass Ergebnisse von SQL-Anfragen immer als Multimengen fungieren. Um eine Duplikateliminierung zur Verfügung zu haben, kann die \textbf{SELECT}-Klausel durch den \textbf{DISTINCT}-Operator erweitert werden. Die Repräsentation der Operatoren der Relationenalgebra durch SQL-Anfragen wird in Tabelle \ref{table:vgl} dargestellt. In vielen Datenbankmanagementsystemen gibt es weitere Funktionalitäten und Operatoren, welche in dieser Arbeit nicht weiter beleuchtet werden. Für die datenbankgestützte Umsetzung linearer Algebra genügt der SQL-Anfragekern wie in Tabelle \ref{table:vgl}.

\begin{table}[h]
    \centering
    \begin{tabular}{|l|l|} \hline
        Relationenalgebra &SQL \\ 
        \hline
        Projektion $\pi$ &\textbf{SELECT} \textbf{DISTINCT} \\ 
        &[\textbf{GROUP BY}] \\
        \hline
        Selektion $\sigma$ &\textbf{WHERE} ohne Schachtelung\\
        \hline
        Verbund $\bowtie$ &\textbf{FROM}, \textbf{WHERE}\\
        &\textbf{FROM} mit \textbf{JOIN} \\
        \hline
        Umbenennung $\beta$ &\textbf{FROM} mit Tupelvariable \\ &\textbf{AS} \\
        \hline
        Differenz $\setminus$ & \textbf{WHERE} mit Schachtelung \\
                  & \textbf{EXCEPT} \\
        \hline
        Vereinigung $\cup$ &\textbf{UNION}  \\
        \hline        
    \end{tabular}
    \caption[tt]{Vergleich des Operatorensystems aus Abschnitt \ref{abs:rela_algebra} mit dem SQL-Anfragekern, vgl. \cite{DBLP:books/daglib/0044627}.}
    \label{table:vgl}
\end{table}
\subsection{Lineare Algebra in SQL}
\label{abs:SQL_linalg}
In diesem Abschnitt werden Darstellungsformen für Vektoren und Matrizen als Relationen vorgestellt. Es werden zwei Strategien erläutert, welche jeweils zur Repräsentation von dicht und dünn besetzten Matrizen genutzt werden. Weiter werden Ideen zur Umsetzung wichtiger Basisoperationen mit Vektoren und Matrizen in SQL beleuchtet, da diese mathematischen Objekte bei zahlreichen statistischen Analysen eingesetzt werden.
\subsection*{Dicht besetzte Matrizen}
Im Folgenden wird das \textit{Coordinate-Schema} \cite{martendiss} als Schema für die Darstellung dichtbesetzter Matrizen genutzt. Dieses Schema gestaltet sich als einfach und ist daher weit verbreitet \cite{saad1990sparskit}.
Für eine weiterführende Diskussion anderer Darstellungsmöglichkeiten und deren Vor- und Nachteile sei auf Marten \cite{martendiss} verwiesen. 
Das Coordinate-Schema beinhaltet drei Arrays, welche den Zeilenindex, Spaltenindex und den Matrixeintrag angeben. Für $A \in \RR^{m \times n}$ kann das Tupel $(i,j,A_{i,j})$ als Schlüssel-Wert-Paar interpretiert werden. So ergibt sich auf natürliche Weise die Überführung von Matrizen und Vektoren in relationale Schemata.
\begin{defi}[Coordinate-Schema]
    \label{def:coordinate_sheme}
    Für $x \in \RR^n$ und $A \in \RR^{m \times n}$ ergeben sich die Relationen
    \begin{align*}
        \mathbf{x}( &\underline{i} \; \; \mathrm{int}, \\
        &v \; \; \mathrm{double})
    \end{align*}
    für den Vektor $x$ und
    \begin{align*}
        \mathbf{A}( &\underline{i} \; \; \mathrm{int}, \\
        &\underline{j} \; \;\mathrm{int},\\
        &v \; \; \mathrm{double})
    \end{align*} für die Matrix $A$. Die Indizes $i$ und $j$ sind jeweils als ganzzahlige Datentypen, engl. \textit{integer}, dargestellt. Die Matrixeinträge werden in \textit{double precision} \cite{30711} abgespeichert. Die unterstrichenen Attribute stellen die Schlüsselattribute, vgl. Definition \ref{def:key} dar. Diese Darstellungsform wird Coordinate-Schema genannt und für dichtbesetzte Matrizen im weiteren Verlauf dieser Arbeit genutzt.
\end{defi}

\begin{bsp}
    \label{besipiel:_coordinate_sheme}
    Ist
    \begin{equation*}
        A=\begin{pmatrix}
            1 & 2 \\
            -5 & 2 \\
            0 & 7 \\
        \end{pmatrix}
        \in \RR^{3 \times 2}
    \end{equation*}
    gegeben, so ergibt sich Coordinate Schema wie in Tabelle \ref{coordinate_scheme_table}.

\begin{table}
    \centering
    \begin{tabular}{|c|c|c|} 
        \hline
    \multicolumn{3}{|c|}{\textbf{A}} \\ \hline
     \hline
     $i$ &$j$ &$v$ \\ 
     \hline
     1 &1 &1\\ 
     \hline
     1 &2 &2\\
     \hline
     2 &1 &$-5$\\
     \hline
     2 &2 &2\\
     \hline
     3 &1 &0\\
     \hline
     3 &2 &7\\
     \hline
    \end{tabular}
    \caption[coordinate]{Das Coordinate Schema zur Matrix $A$ aus Beispiel \ref{besipiel:_coordinate_sheme}.}
    \label{coordinate_scheme_table}
\end{table}
\end{bsp}

\subsection*{Basisoperationen}
\label{abs_basisoperationen}
In diesem Abschnitt werden typische Operationen der linearen Algebra beschrieben. Einfache Funktionen wie die Summation und Multiplikation für reelle Zahlen sind bereits im SQL-Standard \cite{DBLP:books/daglib/0067064} enthalten. Seien nun Vektoren $x,y \in \RR^n$ sowie Matrizen $A,B \in \RR^{m \times n}$ und Skalare $r,s \in \RR$ gegeben. Die jeweiligen Relationen werden gemäß dem Coordinate-Schema erstellt. Die SQL-Anweisung für die Vektoraddition $rx+sy$ lautet
\begin{align*}
    & \mathbf{SELECT} \; x.i \; \mathbf{AS} \; i, \; r*x.v+(s*y.v ) \; \mathbf{AS} \; v \\
    & \mathbf{FROM} \; x \; \mathbf{JOIN} \; y \; \mathbf{ON} \; x.i=y.i
\end{align*}
Ähnlich ergibt sich die Matrixaddition $rA+sB$ zu
\begin{align*}
    & \mathbf{SELECT} \; A.i \; \mathbf{AS} \; i, \; A.j \; \mathbf{AS} \; j, (r*A.v)+(s*B.v ) \; \mathbf{AS} \; v \\
    & \mathbf{FROM} \; A \; \mathbf{JOIN} \; B \; \mathbf{ON} \; A.i=B.i \; \mathbf{AND} \; A.j=B.j
\end{align*} 
Mit der Aggregation \textbf{SUM} können zudem Skalarprodukte und damit Längenbegriffe wie Normen formuliert werden. Die entsprechenden SQL-Anfragen sind im Anhang \ref{app:app_1} zu finden. 

Weitere wichtige Operationen sind die Matrixvektor- und Matrixmatrixmultiplikation. 
Durch Kombination vorheriger Basisoperationen ergibt sich die entsprechenden Transformationen für die Matrixvektormultiplikation $Ax \in \RR^m$ einer Matrix $A \in \RR^{m \times n}$ und eines Vektors $x \in \RR^n$ zu

\begin{align*}
    & \mathbf{SELECT} \; A.i \; \mathbf{AS} \; i, \; \mathbf{SUM} (A.v*x.v) \; \mathbf{AS} \; v\\
    & \mathbf{FROM} \; A \; \mathbf{JOIN} \; x \; \mathbf{ON} \; A.j=x.i \; \\
    & \mathbf{GROUP} \, \mathbf{BY} \; A.i.
\end{align*}
Die Matrix $C=AB \in \RR^{m \times n}$ als Produkt zweier Matrizen $A \in \RR^{m \times k}$ und $B \in \RR^{k \times n}$ lässt sich durch

\begin{align*}
    & \mathbf{SELECT} \; A.i \; \mathbf{AS} \; i, \; B.j \; \mathbf{AS} \; j, \; \mathbf{SUM} (A.v*B.v) \; \mathbf{AS} \; v\\
    & \mathbf{FROM} \; A \; \mathbf{JOIN} \; B \; \mathbf{ON} \; A.j=B.i \; \\
    & \mathbf{GROUP} \, \mathbf{BY} \; A.i, \, B.j
\end{align*}
berechnen.
Schließlich kann auch die Transponierte $A^T$ einer Matrix $A$ einfach berechnet werden, siehe dazu Anhang \ref{app:app_1}.

\subsection*{Dünn besetzte Matrizen}
Bei bestimmten Anwendungen werden dünnbesetzte Matrizen benötigt, deren Zeilen- und Spaltenanzahl erheblich größer als bei dicht besetzten Problemen sind. Oft enthalten diese Matrizen dann eine Menge von Nicht-Null-Elementen, welche im Vergleich zu den Null-Elementen verschwindend gering ist. Daher lohnt es sich, nur die Nicht-Null-Elemente sinnvoll zu speichern. In dieser Arbeit wird das \textit{Compressed-Sparse-Column-Schema}\cite{duff1989sparse} verwendet, um dünn besetzte Matrizen zu repräsentieren. Es besteht ähnlich des Coordinate-Schemas wieder aus drei Arrays. Das erste Array gibt das Spaltenmuster \textbf{colPtr}, das zweite den Zeilenindex \textbf{rowInd} und das dritte den Matrixeintrag \textbf{val} an. Der formale Zusammenhang zwischen einer Matrix $A \in \RR^{m \times n}$ und der Darstellung im Compressed-Sparse-Column-Schema ist durch 
\begin{equation*}
    A_{i,j}=\mathbf{val}[k] \Leftrightarrow (\mathbf{rowInd}[k]=i) \wedge (\mathbf{colPtr}[j] \leq k < \mathbf{colPtr}[j+1])
\end{equation*} 
gegeben. Folgendes Beispiel illustriert diese Beziehung.
\begin{bsp}
    Für die Matrix
    \begin{equation*}
        A=\begin{pmatrix}
            a_{11} &0 &0 &a_{14} \\
            a_{21} &a_{22} &0 &0 \\
            0 &0 &a_{33} &0 \\
            0 &a_{42} &0 &a_{44} \\
        \end{pmatrix}
    \end{equation*}
    ergeben sich die Arrays des Compressed-Sparse-Column-Schemas zu
    \begin{itemize}
        \item \textbf{val}=$[a_{11}, a_{21}, a_{22}, a_{42}, a_{33}, a_{14}, a_{44}]$,
        \item \textbf{rowInd}=$[1, 2, 2, 4, 3, 1, 4]$,
        \item \textbf{colPtr}=$[1, 3, 5, 6, 8]$.
    \end{itemize}
\end{bsp}
Die indirekte Indizierung der Matrixelemente sorgt zwar für eine Verminderung des Speicherbedarfs, erschwert jedoch die rein relationale Umsetzung von Operationen wie die Matrixvektormultiplikation. Hier kann ein objekt-relationaler Ansatz Abhilfe schaffen, bei dem Array-Datentypen genutzt werden, welche jedoch nur in bestimmten relationalen Datenbankmanagementsystemen unterstützt werden. 

\begin{defi}[Spaltenkompression, vgl.\cite{martendiss}]
    \label{def:spaltenkomp}
Eine dünn besetzte Matrix $A \in \RR^{m \times n}$ wird als Relation
\begin{align*}
    \mathbf{A}(&i \; \mathrm{int} \; \mathrm{ARRAY}, \\
               &\underline{j} \; \mathrm{int}, \\
               &v \; \mathrm{double} \; \mathrm{ARRAY}
               )
\end{align*}
gespeichert. Diese Repräsentation wird Spaltenkompression genannt und ist insbesondere für die Matrixvektormultiplikation nützlich.
\end{defi}
In dem Open-Source-Datenbanksystem PostgreSQL\cite{momjian2001postgresql}, welches in dieser Arbeit genutzt wird, kann für die Matrixvektormultiplikation die \textbf{UNNEST}-Funktion genutzt werden. Diese Funktion wandelt ein Array in eine Menge von Tupeln um. Die Matrixvektormultiplikation $Ax \in \RR^m$ mit dünnbesetzter Matrix $A \in \RR^{m \times n}$ kann dann mithilfe der SQL-Anfage

\begin{align*}
    &\mathbf{SELECT} \; i, \mathbf{SUM}(v)\\
    &\mathbf{FROM} (\\
    &\mathbf{SELECT} \; \mathbf{UNNEST}(A.i)\; \mathbf{AS} \; i, \mathbf{UNNEST}(A.v)*x.v \; \mathbf{AS} \; v \\
    &\mathbf{FROM} \; A \; \mathbf{JOIN} \; x \; \mathbf{ON} \; A.j=x.i ) \; \text{temp} \\
    &\mathbf{GROUP} \, \mathbf{BY} \; i
\end{align*}
berechnet werden.

Zusammenfassend stellt sich heraus, dass wesentliche Objekte der linearen Algebra und fundamentale Operationen im SQL-Kern umgesetzt werden können. Für dicht besetzte Matrizen wird das Coordinate-Schema \ref{def:coordinate_sheme} benutzt, während für dünn besetzte Probleme das Spaltenkompression-Schema \ref{def:spaltenkomp} genutzt wird. Beide Darstellungsformen erlauben kompakte SQL-Anfragen für die Matrixmatrix- bzw. Matrixvektormultiplikation. Für eine tiefere Analyse dieser und anderer Darstellungsmöglichkeiten und deren Performance hinsichtlich verschiedener Basisoperationen sei auf Marten \cite{martendiss} verwiesen.


%Im folgenden Abschnitt werden diese Resultate genutzt und im Zusammenhang mit einem Machine- Learning-Verfahren eingesetzt.



