\chapter{Datenbankgestützte Implementierung von CNN}
\label{kap:CNN_in_SQL}
In diesem Kapitel werden Ideen zur Umsetzung der datenbankgestützten Mustererkennung durch tranierte gefaltete neuronale Netze vorgestellt. Der Schlüssel liegt dabei in der effektiven Implementierung der Faltungsoperation als SQL-Anfrage. Gelingt dies, so kann die Vorwärtsrechnung eines CNN durch Komposition von Faltungs-, Pooling- und Matrixvektoroperationen umgesetzt werden. Im Abschnitt \ref{abs:conv_in_sql} werden drei Implementierungsmöglichkeiten der Matrixfaltung, siehe \ref{def:matrix_faltung}, in SQL beleuchtet. Dabei stellt sich heraus, dass es sich lohnt, die diskrete Faltung als lineare Operationen mithilfe der in Kapitel \ref{kap:fund} vorgestellten Basisoperationen umzusetzen. So gelingt es, die Problemstellung \ref{prob:conv_in_sql} zu beantworten und auch für relativ große Grauwertbilder akzeptable Laufzeiten zu erreichen. 

Im Abschnitt \ref{abs:FFN_in_sql} wird die Vorwärtsrechnung eines FFN als Komposition von affin linearen Transformationen mit dem SQL-Anfragekern dargestellt. Zusammen mit den Ergebnissen aus dem vorherigen Abschnitt wird hinsichtlich Problem \ref{prob:ffCCN}im Abschnitt \ref{abs_CNN_in_SQL} eine (objekt-) relationale Umsetzung der Vorwärtsrechnung für das tranierte Modell \ref{modell} zur Ziffernerkennung vorgestellt. Dies spiegelt zugleich das Hauptresultat dieser Arbeit wieder, welches schließlich im Abschnitt \ref{abs:CNN_eval} evaluiert wird. 
\section{Die Faltungsoperation in SQL}
\label{abs:conv_in_sql}
Die Faltung zweier zeitdiskrete Signale stellt die Kernoperation innerhalb von CNN dar. Sind die entsprechenden Signale zweidimensional wie in Problemstellung \ref{prob:conv_in_sql}, so muss die Matrixfaltung $X \ast K$ für $X \in \RR^{h \times b}$ und $K \in \RR^{k \times k}$ mithilfe des im Abschnitt \ref{abs:relation_intro} vorgestellten SQL-Kerns umgesetzt werden. Dazu werden in diesem Abschnitt drei Varianten vorgestellt, welche das Coordinate-Schema bzw. das Spaltenkompression-Schema zur Darstellung der Matrizen $X$ und $K$ nutzen. 
\subsection{Faltung mit Nachbarschaften}
\label{abs:naive_app}
Der erste Ansatz beruht auf den Nachbarschaftsbeziehungen der Pixel innerhalb der Matrix $X$, die durch die Faltung mit einem Kern $K$ mit den Abmessungen $k \times k$ gegeben sind. Dazu werden einige Bezeichnungen im Folgenden eingeführt. Seien $l=\lfloor k/2 \rfloor$ und die Mengen
\begin{align*}
    N:=\{(i,j) \; :\; 1 \leq i \leq b, 1 \leq j \leq h \}
\end{align*} 
sowie
\begin{align*}
    F:=\{(i,j) \; :\; -l \leq i \leq l, -l \leq j \leq l \}
\end{align*} 
gegeben, welche die Positionen der Matrizen $X$ und $K$ widerspiegeln. Hier wird wieder die spezielle Indizierung des Kerns $K$ wie in Bemerkung \ref{bem:K_conv_komp} genutzt. Nun kann für jeden Pixel $(i,j)$ von $X$ eine Umgebung $U(i,j)$  in Abhängigkeit von $F$ definiert werden, und zwar
\begin{equation}
    \label{eq:neighborhood}
    U(i,j):=\{(i', j') \; : \; (i'-i, j'-j) \in F \}.
\end{equation}
Die Menge $U(i,j)$ wird auch als Nachbarschaft des Pixels $(i,j)$ bezeichnet.
Die Matrixfaltung $Y= X \ast K$ lässt sich mit den Nachbarschaften (\ref{eq:neighborhood}) durch
\begin{equation}
    \label{eq:naive_approach}
    Y_{i,j}=\sum_{(i',j') \in U(i,j)} X_{i', j'} K_{i'-i, j'-j}, \; \; \forall i \in [h], \forall j \in [b]
\end{equation}
berechnen. Dabei wird $X$ außerhalb des Definitionsbereiches mit Nullen aufgefüllt, sodass das Ergebnis $Y$ wieder die gleichen Abmessungen wie $X$ besitzt.

Zur Umsetzung der Faltungsoperation sind also zunächst die Nachbarschaften für jeden Pixel von $X$ zu berechnen. In SQL kann dies mithilfe des kartesischem Produkts implementiert werden. Dazu bezeichnen $\mathbf{X}$ und $\mathbf{K}$ die Relation zur Darstellung der Matrizen $X$ und $K$ im Coordinate-Schema. Eine rein relationale Umsetzung von (\ref{eq:naive_approach}) ist durch die SQL-Anfrage \ref{sql:naive} gegeben. Zur Übersicht sind die Attributbezeichnungen groß geschrieben und die SQL-Klausel blau gekennzeichnet. 

\lstinputlisting[label=sql:naive, caption=SQL-Code zur Umsetzung der Faltung mit Nachbarschaften, language=SQL]{sql_code/neighborhood.sql}

In der Teilanfrage (Zeile 4-14) werden die Nachbarschaften aller Pixel in der temporären $\mathbf{KREUZ}$ Relation berechnet. Dabei wird die \textbf{BETWEEN}-Funktion zur kompakten Darstellung der Konstantenselektion bezüglich $l=\lfloor k/2 \rfloor$ genutzt. In den Zeilen 15-17 werden dann die Nachbarschaften über die entsprechenden Indizies der Filtermatrix verbunden und schließlich die \textbf{SUM}-Funktion genutzt, um das Faltungsergebnis zu berechnen. Dieser naive Ansatz nutzt keine lineare Algebra in Form von Matrixvektor- oder Matrixmatrixmultiplikation und ist hinsichtlich des Problems \ref{prob:conv_in_sql} schon für verhältnismäßig kleine Grauwertbilder ineffizient. Zu Erkennen ist dies in der Abbildung \ref{abb:laufzeit_naive}, bei der die Laufzeiten der SQL-Anfrage \ref{sql:naive} in Abhängigkeit von der Dimension $n$ für allgemeine Matrizen $X \in [0,1]^{n \times n}$ dargestellt ist.

TODO Grafik ergebnis erklären.

Eine Verbesserung der Laufzeiten kann mithilfe von Umsetzungstabellen, engl. \textit{Lookup tables}, erreicht werden. Da die Dimensionen aller vorkommenden Merkmalskarten und Kerne eines CNN von Anfang an durch die Wahl der Hyperparameter festgelegt werden, müssen die Nachbarschaften für die Faltung und das Pooling nur einmalig berechnet werden. Dies kann zudem vor der eigentlichen Erkennungsphase durchgeführt werden. So wird zwar der Speicheraufwand erhöht, aber der Zeitaufwand hinsichtlich der Faltungs- und Poolingoperation deutlich vermindert. Dazu werden pro Faltungs- und Poolingschicht jeweils eine Umsetzungstabelle \textbf{U} in der Form 
\begin{align*}
    \mathbf{U}( &\underline{i} \; \; \mathrm{int}, \\
    &\underline{j} \; \;\mathrm{int},\\
    &\underline{\text{id}} \; \; \mathrm{int}, \\
    &\text{istrich} \; \; \mathrm{int},\\
    &\text{jstrich}\; \; \mathrm{int})
\end{align*}
mit dem zusammengesetzten Schlüssel $(i,j,\text{id})$ benötigt. Hier werden für jeden Pixel $(i,j)$ die Nachbarpixel $(i', j') \in U$ mit einer entsprechenden Nummer $\text{id}$ hinterlegt. So wird die zeitintensive Berechnung der Nachbarschaften mit dem  kartesischen Produkt in der Anfrage \ref{sql:naive} umgangen. Die Laufzeiten dieser Verbesserung sind in Abbildung \ref{abb:laufzeit_naive_verb} dargestellt.

TODO Grafik ergebnis erklären.

\subsection{Faltung als Matrixvektorprodukt}
\label{abs:conv_using_sparse}
Zwei beliebige Funktionen $f,g: D \rightarrow \mathbb{R}$ mit endlichem Definitionsbereich $D$ können als zeitdiskrete Signale $f=(f_0, \ldots, f_{n-1})^T \in \mathbb{R}^{n}$ und $g=(g_0, \ldots, g_{n-1})^T \in \mathbb{R}^{n}$ aufgefasst werden. %Durch das Fortsetzen mit Nullen besitzen die Vektoren $f$ und $g$ die gleiche Länge. 
Die diskrete Faltung dieser eindimensionalen Signale wird im Folgenden erklärt.

\begin{defi}
    \label{def:cycconv}
    Das Faltungsergebnis $y \in \RR^{n}$ zweier zeitdiskreter Signale $f \in \RR^n$ und $g \in \RR^n$ ist durch
    \begin{equation}
        y_k:=\sum_{j=0}^{k} f_j g_{k-j}, \; \; 0 \leq k \leq n-1
    \end{equation}
    definiert.
\end{defi}
In diesem Fall kann die diskrete Faltung von $f$ und $g$ als Matrixvektorprodukt mit Toeplitz-Matrizen formuliert werden. 

\begin{defi}[Toeplitz-Matrix, Zyklische Matrix]
    \label{def:toeplitzM}
    Eine diagonalkonstante Matrix $A \in \RR^{n \times n}$ der Gestalt
    \begin{equation*}
    A=
    \begin{pmatrix}
        a_0 & a_{-1} &a_{-2} &\ldots &\ldots &a_{-(n-1)} \\ 
        a_1 & a_0 &a_{-1} &\ddots & &\vdots \\
        a_2 & a_1 &\ddots &\ddots &\ddots &\vdots\\
        \vdots & \ddots &\ddots &\ddots &a_{-1} &a_{-2}\\
        \vdots & &\ddots &a_1 &a_0 &a_{-1} \\
        a_{n-1} &\ldots &\ldots &a_{2} &a_{1} &a_0
    \end{pmatrix}
\end{equation*}
    wird Toeplitz\footnote{Otto Toeplitz 1881-1940}-Matrix genannt. Hierbei gilt $A_{i,j}=A_{i+1,j+1}=a_{i-j}$ für alle Indizies $1 \leq i, j \leq n$. Eine quadratische Toeplitzmatrix ist damit durch ihre erste Zeile und Spalte eindeutig bestimmt. Für den Spezialfall $a_i=a_{-(n-i)}=a_{i-n}$ für alle $1 \leq i \leq n-1$ wird $A$ zyklische Matrix genannt.
\end{defi}

%\begin{defi}[Zyklische Matrix, vgl. Gray\cite{gray2006toeplitz}]
  %  \label{def:zykM}
   % Eine quadratische Matrix heißt zyklisch im Vektor $a=(a_0, \ldots, a_{n-1})^T \in \RR^n$, wenn sie die Gesatlt
    %\begin{equation*}
        %\mathrm{zyk}(a):=
        %\begin{pmatrix}
            %a_0 & a_{n-1} &a_{n-2} &\ldots &a_1 \\ 
            %a_1 & a_0 &a_{n-1} & \ldots &a_2 \\
            %a_2 & a_1 &a_0 & \ldots &a_3 \\
            % &\ddots &\ddots &\ddots & \\
            %a_{n-1} &a_{n-2} &a_{n-3} &\ldots &a_0
        %\end{pmatrix}
    %\end{equation*}
   % besitzt.
%\end{defi}    
    
Für ein zeitdiskrete Signal $g \in \mathbb{R}^{n}$ wird die Toeplitz-Matrix 
\begin{equation*} 
    G_n=\begin{pmatrix}
        g_0 & 0 &0 &\ldots &\ldots &0 \\ 
        g_1 & g_0 &0 &\ddots & &\vdots \\
        g_2 & g_1 &\ddots &\ddots &\ddots &\vdots\\
        \vdots & \ddots &\ddots &\ddots &0 &0\\
        \vdots & &\ddots &g_1 &g_0 &0 \\
        g_{n-1} &\ldots &\ldots &g_{2} &g_{1} &g_0
    \end{pmatrix}
\end{equation*}
konstruiert. Sei ein zeitdiskretes Signal $f \in \RR^{n}$ gegeben und der Vektor $y \in \RR^n$ durch
\begin{equation*}
    y:=G_n f =\begin{pmatrix}
        g_0 & 0 &0 &\ldots &\ldots &0 \\ 
        g_1 & g_0 &0 &\ddots & &\vdots \\
        g_2 & g_1 &\ddots &\ddots &\ddots &\vdots\\
        \vdots & \ddots &\ddots &\ddots &0 &0\\
        \vdots & &\ddots &g_1 &g_0 &0 \\
        g_{n-1} &\ldots &\ldots &g_{2} &g_{1} &g_0
    \end{pmatrix}
    \begin{pmatrix}
        f_0 \\
        f_1 \\
        f_2 \\
        \vdots \\
        \vdots \\
        f_{n-1}
    \end{pmatrix} \\
    = \begin{pmatrix}
        g_0 f_0 \\
        g_1 f_0+ g_0 f_1 \\
        \sum_{j=0}^2 f_j g_{2-j}  \\
        \vdots \\
        \vdots \\
        \sum_{j=0}^{n-1} f_j g_{n-1-j} 
    \end{pmatrix}
\end{equation*}
mit den Einträgen 
\begin{equation*}
   y_k=\sum_{j=0}^k f_j g_{k-j}, \; \; 0 \leq k \leq n-1
\end{equation*}
gegeben.
Dann spiegelt $y$ das Ergebnis der eindimensionalen diskreten Faltung von $f$ und $g$ wider. Die Faltung zweidimensionaler Signale kann mithilfe von zyklischen Blockmatrizen dargestellt werden.
    %Matrix im Vektor $f$. Sei weiter $g \in \mathbb{R}^{n}$. Dann lässt sich mit
%\begin{equation*}
 %       (F g)_k=\sum_{j=0}^{n-1}  f_{k-j} g_j,  \; \; k=0, \ldots, n-1
  %  \end{equation*}
   % die diskrete Faltung von $f$ und $g$ darstellen. Dabei werden Indizies außerhalb von $0, \ldots, n-1$ zyklisch durch Modulo-Rechnung ($\mathrm{mod} \; n)$ in den gültigen Indexbereich abgebildet. Zyklische Matrizen aus Definition \ref{def:zykM} stellen Spezialfälle von Toeplitz-Matrizen dar.
\begin{defi}
    \label{def:double_circ}
    Eine Blockmatrix $A \in \RR^{n^2 \times n^2}$ bestehend aus Blockmatrizen $B_{i,j} \in \RR^{n \times n}$ heißt zyklische Blockmatrix, genau dann wenn die Matrizen $B_{i,j}$ für alle $ 1 \leq i, j \leq n$ zyklisch im Sinne von Definietion \ref{def:toeplitzM} sind.
\end{defi}

Die Konstruktion solcher zyklischen Blockmatrizen soll im Folgenden beleuchtet werden. Dazu  seien für $h=b=n$ die Matrizen $X \in \RR^{n \times n}$ und $K \in \RR^{k \times k}$ einer Faltungschicht gegeben. Zunächst wird der Kern $K$ mithilfe des zero paddings ebenfalls in eine $n \times n$-Matrix eingebettet. Dazu wird der Kern ja nach der gewünschten Größe des Faltungsergebnis von unten und von rechts mit Nullen aufgefüllt, siehe dazu Beispiel \ref{bsp:Kzeropad}.
Weiter bezeichne $\mathrm{vec}(X)$ die Transformation der Matrix $X$ in einen Vektor der Länge $n^2$, indem die Spalten von $X$ untereinander geschrieben werden, ähnlich wie bei der Flatten-Funktion \ref{def:flatten} aus Kapitel \ref{kap:CNN}. Das folgende Lemma liefert die Darstellung der Faltungsoperation als Matrixvektorprodukt.

\begin{lem}[vgl. Jain\cite{jain}, Goodfellow\cite{Goodfellow-et-al-2016}]
    Für $K \in \RR^{n \times n}$ wird die zyklische Blockmatrix $A \in \RR^{n \times n}$ als
    \begin{equation*}
        A=\begin{bmatrix}
            \mathrm{zyk}(K_{1,:}) &\mathrm{zyk}(K_{2,:}) &\ldots &\mathrm{zyk}(K_{n,:}) \\
            \mathrm{zyk}(K_{n,:}) &\mathrm{zyk}(K_{1,:}) &\ldots & \; \; \;\mathrm{zyk}(K_{n-1,:})\\
            \vdots &\vdots &\ddots &\vdots\\
            \mathrm{zyk}(K_{2,:}) &\mathrm{zyk}(K_{3,:}) &\ldots &\mathrm{zyk}(K_{1,:})
        \end{bmatrix}
    \end{equation*}
    gegeben. Dann entspricht $Y=A \mathrm{vec}(X)$ dem Ergebnis der Matrixfaltung $X \ast K$. Die Matrix $A$ ist dünnbesetzt. 
\end{lem}

\begin{bsp}
    \label{bsp:Kzeropad}
    TODO
\end{bsp}

\subsection{Diskrete Fourier-Transformation}
Die Diskrete Fourier\footnote{Jean Baptiste Joseph Fourier 1786-1830}-Transformation ist eine Methode aus dem Bereich der Fourier-Analysis. Dabei werden zeitdiskrete endliche Signale auf sogenannte diskrete, periodische Frequenzspektren abgebildet. In diesem Kontext wird zwischen Zeitbereich und Frequenzbereich unterschieden.

\begin{defi}[Diskrete Fourier-Transformation]
    \label{def:dft}
    Im Zeitbereich sei ein diskretes Signal $x=(x_0, \ldots, x_{n-1})^T \in \RR^n$ gegeben. Dann wird mit $\hat{x}=(\hat{x}_0, \ldots, \hat{x}_{n-1}) \in \mathbb{C}^n$ das Ergebnis der diskreten Fourier-Transformation, kurz $\hat{x}=\mathrm{DFT}(x)$, im Frequenzbereich bezeichnet. Die sogenannten Fourier-Koeffizienten sind als 
    \begin{equation*}
        \hat{x}_k:=\sum_{j=0}^{n-1} \mathrm{e}^{- \frac{2 \pi i}{n} j k} \cdot x_j
    \end{equation*}
    für $0 \leq k \leq n-1$ definiert.
\end{defi}
Mit der inversen Fourier-Transformation kann aus dem Signal im Frequenzbereich das Signal im Zeitbereich rekonstruiert werden. Damit ist es möglich, Signale im Frequenzbereich zu manipulieren und zwischen Zeit- und Frequenzbereich beliebig zu wechseln.
\begin{defi}[Inverse Diskrete Fourier-Transformation]
    Sei $\hat{x}=(\hat{x}_0, \ldots, \hat{x}_{n-1}) \in \mathbb{C}^n$. Mit den Koeffizienten
    \begin{equation*}
        x_j:= \frac{1}{n} \sum_{k=0}^{n-1} \mathrm{e}^{\frac{2 \pi i}{n} j k} \cdot \hat{x}_k, \; \; 0 \leq j \leq n-1
    \end{equation*}
    lässt sich die inverse diskrete Fourier-Transformation, kurz $x=\mathrm{iDFT}(\hat{x})$, angeben.
\end{defi}
Die diskrete Fourier-Transformation aus Definition \ref{def:dft} lässt sich in ein Matrixvektorprodukt $\hat{x}=Fx$ überführen, wobei $F \in \mathbb{C}^{n \times n}$ eine symmetrische Matrix der Gestalt
\begin{equation}
    \label{eq:FM}
    F=\begin{pmatrix}
        &1 &1 &1 &\ldots &1 \\
        &1 &\omega_n &\omega_n^2 &\ldots &\omega_n^{(n-1)} \\
        &1 &\omega_n^2 &\omega_n^4 &\ldots &\omega_n^{(n-2)} \\
        &\vdots &\vdots & &\ddots &\vdots \\
        &1 &\omega_n^{(n-1)} &\omega_n^{(n-2)}  &\ldots &\omega_n
    \end{pmatrix}
\end{equation}
mit 
\begin{equation*}
    \omega_n^{j}:=\mathrm{e}^{- \frac{2 \pi i}{n} j}, \; \; 0 \leq j \leq n-1
\end{equation*}
ist. Diese Matrix wird Fourier-Matrix genannt und deren Einträge $\omega_n^{j}$ als $n$-te Einheitswurzeln bezeichnet. Es gilt $\omega_n^n=1$.
\begin{lem}
    \label{lem:Finv}
    Es gilt $F^H=\bar{F}$ und die Matrix $\frac{1}{\sqrt{n}} F$ ist unitär. Für $x \in \RR^n$ sei $\hat{x}=Fx$. Dann gilt $F^{-1}=\frac{1}{n} \bar{F}$ und $x= \frac{1}{n}\bar{F} \hat{x}$.
\end{lem}
\begin{proof}
    Wegen $F=F^T$ gilt 
    \begin{equation*}
        F^H=\bar{{F}}^T=\bar{F}.
    \end{equation*}
    Mit $W:=F\bar{F}$ gilt $W_{k,j}=\sum_{l=0}^{n-1} \omega_n^{(j-k)l}$. Ist $k=j$ so ergeben sich die Einträge auf der Hauptdiagonalen von $W$ zu $n$. Ist $k \neq j$, so ist $\omega_0:=\omega_n^{j-k} \neq 1$ eine $n$-te Einheitswurzel.
    Mit der geometrischen Summenformel gilt
    \begin{equation*}
        W_{k,j}=\sum_{l=0}^{n-1} \omega_0^l=\frac{1-\omega_0^n}{1-\omega_0}=0.
    \end{equation*} 
    Also ist $\left(\frac{1}{\sqrt{n}}\right) F\left(\frac{1}{\sqrt{n}}\right) F^H=I$ und damit $\frac{1}{\sqrt{n}} F$ unitär. Schließlich gilt $\frac{1}{n} \bar{F} F=\frac{1}{n} F \bar{F}= I$ und damit $\hat{x}=Fx \Leftrightarrow \frac{1}{n}\bar{F} \hat{x}=x$.
\end{proof} 
Die inverse diskrete Fourier-Transformation lässt sich mithilfe der diskreten Fourier-Transformation berechnen. Dieser Zusammenhang wird insbesondere für die spätere datenbankgestützte Implementierung der Fourier-Transformationen genutzt.
\begin{lem}
    \label{lem:inversedftasdft}
    Sei das Fourier-Paar
    \begin{align*}
        \mathrm{DFT}(x)&: \; \;\hat{x}_k=\sum_{j=0}^{n-1} \mathrm{e}^{- \frac{2 \pi i}{n} j k} \cdot x_j, \\ 
        \mathrm{iDFT}(\hat{x})&:\; \; x_j= \frac{1}{n} \sum_{k=0}^{n-1} \mathrm{e}^{\frac{2 \pi i}{n} j k} \cdot \hat{x}_k
    \end{align*}
    für $x=(x_0, \ldots, x_{n-1})^T \in \mathbb{R}^n$ gegeben. Dann gilt $x=\frac{1}{n} (DFT(\hat{x}^*))^*$. Hierbei ist mit ${}^*$ die komplexe Konjugation gemeint.
\end{lem}
\begin{proof}
  Für alle $0 \leq j \leq n-1$  gilt
  \begin{align*}
    x_j^{*}&=\frac{1}{n} \sum_{k=0}^{n-1} \mathrm{e}^{-\frac{2 \pi i}{n} j k} \cdot \hat{x}^*_k \\
    &=\frac{1}{n} \mathrm{DFT}(\hat{x}^*)_j.
  \end{align*}
  Die Konjugation auf beiden Seiten liefert die Aussage.
\end{proof}
Wird ein zweidimensionales diskretes Signal in Form einer Matrix $X \in \RR^{n \times n}$ betrachtet, lässt sich die zweidimensionale diskrete Fourier-Transformation definieren. 
\begin{defi}
    Die zweidimensionale diskrete Fourier-Transformation für $X \in \RR^{n \times n}$, kurz $\hat{X}=2\mathrm{DFT}(X)$, ist als
    \begin{align*}
        \hat{X}_{u+1,v+1}:&= \sum_{l=0}^{n-1} \sum_{j=0}^{n-1} X_{l+1,j+1} \cdot \mathrm{e}^{\frac{2 \pi i}{n} -(lu+jv)} \\
        &=\sum_{l=0}^{n-1} \mathrm{e}^{-\frac{2 \pi i}{n} l u} \left(\sum_{j=0}^{n-1} X_{l+1,j+1} \cdot \mathrm{e}^{-\frac{2 \pi i}{n} j v}\right), \; \; 0 \leq u, v \leq n-1
    \end{align*}
    definiert.
\end{defi}
Die zweidimensionale diskrete Fourier-Transformation ist als Hintereinanderausführung von zwei eindimensionalen Fourier-Transformationen, vgl. Definition \ref{def:dft}, zu verstehen. Zuerst wird die $\mathrm{DFT}$ der Zeilen und anschließend die $\mathrm{DFT}$ der Spalten von $X$ berechnet. So lässt sich $\hat{X}=FXF^T$ als Matrixmatrixprodukt mit der Matrix $F$ aus (\ref{eq:FM}) darstellen.

Zwischen der zyklischen Faltung \ref{def:cycconv} und der diskreten Fourier-Transformation \ref{def:dft} besteht ein fundamentaler Zusammenhang, und zwar das Faltungstheorem. Eine Version davon wird im weiteren Verlauf dieser Arbeit genutzt, um die Matrixfaltung, vgl. Definition \ref{def:matrix_faltung}, mithilfe von Fourier-Transformationen zu berechnen.

\begin{satz}[Zyklisches Faltungstheorem]
    \label{satz:conv_theorem}
    Seien Vektoren $f,g \in \RR^{n}$ gegeben und $y= f \ast g$ das Ergebnis der zyklischen Faltung. Dann gilt
    \begin{equation}
        \mathrm{DFT}(y)=\mathrm{DFT}(f) \odot \mathrm{DFT}(g).
    \end{equation}
    Dabei bezeichne $\odot$ die elementweise Multiplikation der Einträge von den beteiligten Vektoren.
\end{satz}
\begin{proof}
    Ein Beweis ist von Smith\cite{smith2007mathematics} gegeben.
\end{proof}
\begin{bem}
    Seien die Matrizen $X \in \RR^{n \times n}$ und $K \in \RR^{k \times k}$ mit ungeradem $k$ gegeben. Weiter sei $l=\lfloor k/2 \rfloor$. Die Matrixfaltung $Y= X \ast K$ ist durch
    \begin{equation*}
        Y_{i,j}=\sum_{u=-l}^l \sum_{v=-l}^l X_{i+u, j+v} K_{u,v}, \; \; 1 \leq i, j \leq n
    \end{equation*}
    erklärt, vgl. Bemerkung \ref{bem:K_conv_komp}.
    Der Kern $K$ wird in eine $n \times n$-Matrix wie in \ref{lem:circ_extension} eingebettet und diese wird wieder mit $K \in \RR^{n \times n}$ bezeichnet wird. Stehen die zweidimensionalen diskreten Fourier-Transformationen $\hat{X}=\mathrm{2DFT}(X)$ und $\hat{K}=\mathrm{2DFT}(K)$ zur Verfügung, so gilt mit dem Faltungstheorem \ref{satz:conv_theorem} der Zusammenhang
    \begin{align*}
        \mathrm{2DFT}(Y)&=\mathrm{2DFT}(X) \odot \mathrm{2DFT}(K). 
        %\Leftrightarrow &=\mathrm{i2DFT}(\hat{X} \odot \hat{K}).
    \end{align*}
    % bereits um 180 Grad gedreht, vgl. Bemerkung \ref{bem:K_conv_komp}, 
\end{bem}
Die Matrixfaltung innerhalb einer Faltungsschicht eines CNN lässt sich mit den obigen Resultaten in drei Schritten berechnen.
\begin{itemize}
    \item[1.] Es sind jeweils die zweidimensionalen diskreten Fourier-Transformationen für die Eingabe $\hat{X}$ und den Kern $\hat{K}$ zu berechnen.
    \item[2.] Die Matrix $\hat{Y}= \hat{X} \odot \hat{K}$, welche sich aus der elementweisen Multiplikation ergibt, ist zu bestimmen.
    \item[3.] Schließlich stellt $Y=\mathrm{i2DFT}(\hat{Y})$ die Matrixfaltung dar, welche mithilfe der inversen diskreten Fourier-Transformation ermittelt wird.    
\end{itemize} 
Für Schritt 1 und Schritt 3 kann wegen Lemma \ref{lem:Finv} und Lemma \ref{lem:inversedftasdft} die Fourier-Matrix $F$ benutzt werden. Die Aufgabe besteht nun darin, die Berechnungen in Algorithmus \ref{alg:conv_as_2dft} datenbankgestützt umzusetzen. 
\begin{algorithm}[h]
    \caption{Matrixfaltung mit diskreten Fourier-Transformationen}
    \label{alg:conv_as_2dft}
    \begin{algorithmic}
    \Require  Eingabematrix $X \in \RR^{n \times n}$, eingebetteter Kern $K \in \RR^{n \times n}$, Fourier-Matrix $F \in \RR^{n \times n}$ 
    \Ensure Matrixfaltung $Y= X \ast K$
    \State Berechne die zweidimensionalen diskreten Fourier-Transformationen:
    \State $\hat{X}=F X F^T$
    \State $\hat{K}=F K F^T$ 
    \State Berechne das Produkt mit der elementweisen Multiplikation:
    \State $\hat{Y}= \hat{X} \odot \hat{K}$
    \State Bestimme die inverse Fourier-Transformation:  
    \State $Z=\hat{Y}^*$
    \State $\hat{Z}=F Z F^T$
    \State $Y=\frac{1}{n^2}\hat{Z}^*$
    \end{algorithmic}
\end{algorithm}

Dies gelingt, da ausschließlich Basisoperationen wie die Matrixmatrixmultiplikation sowie das Adjungieren von Matrizen benötigt werden. Die elementweise Multiplikation und die Konjugation können als einfache skalare Funktionen implementiert werden. Die Berechnung der DFT mit der Matrix $F$ benötigt $n(2n-1)$ Fließkomma-Operationen. Da die Matrix $F$ nur von den Dimensionen der beteiligten Matrizen abhängt und diese durch die Hyperparameter des verwendeten CNN festgelegt sind, kann $F$ vor der Vorwärtsrechnung in einer Relation gespeichert werden. 
Die Matrix $F$ besitzt komplexwertige Einträge und daher wird das Attribut \textbf{v} in die Attribute \textbf{re} und \textbf{im} aufgeteilt, um den Real- und Imaginärteil getrennt zu speichern. Die Multiplikation zweier komplexer Zahlen $z_1$ und $z_2$ ist durch
\begin{align*}
    z_1 \cdot z_2 &=(\Re(z_1)+ i \Im(z_1))(\Re(z_2)+i \Im(z_2))\\
    &=(\Re(z_1) \cdot \Re(z_2)-\Im(z_1) \cdot \Im(z_2))+ i (\Re(z_1) \cdot \Im(z_2)+ \Im(z_1) \cdot \Re(z_2))
\end{align*}
erklärt.
Darüber hinaus können auch die Fourier-Transformierten $\hat{K}$ für alle beteiligten Kerne $K$ bereits vor der Erkennungsphase bestimmt werden. So kann die Berechnungszeit verkürtzt werden.

Seien $X \in [0,1]^{n \times n}$ und \textbf{X} sowie \textbf{F} die Relation zur Darstellung der Matrizen $X$ und $F$ im Coordinate-Schema. Im ersten Berechnungsschritt ist lediglich die Matrix $\mathrm{2DFT}(X)$ zu bestimmen. Die entsprechende SQL-Anfrage \ref{sql:dft} lässt sich formulieren. Mithilfe sogenannter Common Table Expressions, zu Erkennen am Schlagwort \textbf{WITH}, können temporäre Relationen berechnet werden. So gelingt die iterative Berechnung der Matrixmatrixprodukte. Die erste Relation \textbf{FT}
in den Zeilen 1-6 ermittelt $F^T$. In den Zeilen 7-15 wird $X F^T$ und anschließend in den Zeilen 16-24 $F X F^T$ in der Relation \textbf{FXFT} berechnet. 
Schließlich folgt in den letzten Zeilen die Ausgabe der zweidimensionalen diskreten Fourier-Transformation. Numerische Resultate zum Zeit- und Speicheraufwand sind der Abbildung \ref{abb:dft_insql}
zu entnehmen.

TODO Grafik erklären

\lstinputlisting[label=sql:dft, caption=SQL-Code zur Umsetzung der zweidimensionalen diskreten Fourier-Transformation, language=SQL]{sql_code/dft_ansatz_FXFT.txt}

Im zweiten Berechnungsschritt ist eine elementweise Multiplikation auszuführen. Angenommenen die Matrizen $\hat{X}$ und $\hat{K}$ sind als Relationen \textbf{X}
und \textbf{K} im Coordinate-Schema hinterlegt. Dann wird $\hat{X} \odot \hat{K}$ in der SQL-Anfrage \ref{sql:elementweise} implementiert.
Der dritte Berechnungsschritt lässt sich analog zum ersten Schritt darstellen. Dabei ist an zwei Stellen lediglich das Adjungieren einer komplexen Matrix notwendig, siehe Anhang \ref{app:app_1}. 

\lstinputlisting[label=sql:elementweise, caption=SQL-Code zur Umsetzung der elementweisen Multiplikation, language=SQL]{sql_code/dft_ansatz_elemwise.txt}

Wird zur Berechnung der DFT die sogenannte schnelle Fourier-Transformation (engl. \textit{Fast-Fourier-Transformation}, kurz: FFT) genutzt, kann der Zeitaufwand von $\mathcal{O}(n^2)$ auf $\mathcal{O}(n \log n)$ vermindert werden. Verschiedene Möglichkeiten, die FFT in SQL zu implementieren, werden in Marten et. al.\cite{DBLP:conf/adbis/Marten0019} präsentiert. In dieser Arbeit wird diskrete Fourier-Transformation wie in Algorithmus \ref{alg:conv_as_2dft} behandelt. 

\subsection{Zusammenfassung}
\label{abs:sum_conc_in_sql}


\section{Datenbankgestützte Vorwärtsrechnung für CNN}
\label{abs_CNN_in_SQL}
Alle Parameter sind vorher trainiert. ausführen!! TODO
\subsection*{Linearkombinationen}
\subsection*{Pooling}
Die datenbankgestützte Umsetzung von Pooling-Schichten gelingt direkt durch die Nutzung von Nachbarschaften wie in Abschnitt \ref{abs:naive_app}. Da die Dimensionen aller vorkommenden Merkmalskarten und Kerne eines CNN durch die Wahl der Hyperparameter festgelegt werden, müssen die Nachbarschaften beim Pooling nur einmalig berechnet werden. Des Weiteren werden Funktionen wie \textbf{MAX} und \textbf{MEAN} im SQL-Standard unterstützt, sodass Mittelwert-Pooling und Maximum-Pooling implementiert werden können.

Eine weitere Möglichkeit besteht darin, das Mittelwert-Pooling mit den Schrittweiten $p:=p_h=p_b$ als Faltungsoperation mit dem sogenannten Mittelwert-Kern $\frac{1}{p^2} \mathbf{1} \in \RR^{p \times p}$ zu implementieren. An dieser Stelle können Resultate aus dem vorherigen Abschnitt \ref{abs:conv_in_sql} genutzt werden, um abzuschätzen, welcher Ansatz für das gewählte Modell besser geeignet ist. Schließlich ist auch die Flatten-Funktion, vgl. Definition \ref{def:flatten}, leicht in SQL umsetzbar. 

TODO beispiel fatten code
 
\subsection*{Vorwärtsgerichtete neuronale Netze}
Die letzte Schicht eines CNN besteht meistens aus einem FFN mit einer oder mehreren verdeckten Neuronenschichten. Die Theorie von FFN wird in Kapitel \ref{kap:NN} vorgestellt. Dabei wird die Ausgabe eines neuronalen Natzes mittels Vorwärtsrechnung, vgl. \ref{alg:ff}, berechnet. Diese lässt sich ausschließlich mit bereits vorgestellten Basisoperationen wie der Matrixvektormultiplikation bzw. Vektoraddition und einfachen Funktionsauswertung darstellen. Wird das Modell \ref{modell} zur Klassifikation von Ziffern genutzt, so ist die Vorwärtsrechnung für eine Neuronenschicht datenbankgestützt umzusetzen. Die Verallgemeinerung für beliebig viele Schichten wurde bereits in einer Projektarbeit der Universität Rostock untersucht \cite{myprojekt}. 

Sei die Gewichtsmatrix $W \in \RR^{192 \times 10}$ sowie der Biasvektor $b \in \RR^{10}$ wie in Abschnitt \ref{abs:model_mnist} gegeben. Die entsprechenden Relationen \textbf{W} und \textbf{B} werden gemäß dem Coordinate-Schema erstellt. Weiter sei $\psi$ eine beliebige Aktivierungsfunktion, im Modell \ref{modell} ist $\psi$ die logistische Funktion. In SQL-Anfragen wird dafür die Variable $T$ verwendet. Schließlich sei in der Relation \textbf{FLAT} der Vektor $f=T_f(X)$ der Flatten-Schicht gespeichert, welcher als Eingabe des FFN dient. Die Ausgabe des FFN und damit des gesamten CNN lässt sich durch die SQL-Anfrage \ref{sql:ffn} berechnen. In den Zeilen 1-9 wird das Matrixvektorprodukt $Wf$ berechnet, welches anschließend mit dem Biasvektor $b$ manipuliert wird. Schließlich werden die Aktivierungen der Ausgabeschicht mit der Funktion $T$ ermittelt. In den Zeilen 10-15 wird der Index der maximale Aktivierung selektiert, welcher, vermindert um Eins, die Klassifikation der Ziffer darstellt.

\lstinputlisting[label=sql:ffn, caption=SQL-Code zur Umsetzung der Vorwärtsrechnung eines einschichtigen FFN, language=SQL]{sql_code/ffn_in_sql.txt}
\section{Evalution}
Eine vollständige Erkennungsphase ist im Anhang \ref{app:app_2} zu finden.
\label{abs:CNN_eval}