\chapter{Datenbankgestützte Implementierung von CNN}
\label{kap:CNN_in_SQL}
In diesem Kapitel werden Ideen zur Umsetzung der datenbankgestützten Mustererkennung durch tranierte gefaltete neuronale Netze vorgestellt. Der Schlüssel liegt dabei in der effektiven Implementierung der Faltungsoperation als SQL-Anfrage. Gelingt dies, so kann die Vorwärtsrechnung eines CNN durch Komposition von Faltungs-, Pooling- und Matrixvektoroperationen umgesetzt werden. Im Abschnitt \ref{abs:conv_in_sql} werden drei Implementierungsmöglichkeiten der Matrixfaltung, siehe \ref{def:matrix_faltung}, in SQL beleuchtet. Dabei stellt sich heraus, dass es sich lohnt, die diskrete Faltung als lineare Operationen mithilfe der in Kapitel \ref{kap:fund} vorgestellten Basisoperationen umzusetzen. So gelingt es, die Problemstellung \ref{prob:conv_in_sql} zu beantworten und auch für relativ große Grauwertbilder akzeptable Laufzeiten zu erreichen. 

Im Abschnitt \ref{abs:FFN_in_sql} wird die Vorwärtsrechnung eines FFN als Komposition von affin linearen Transformationen mit dem SQL-Anfragekern dargestellt. Zusammen mit den Ergebnissen aus dem vorherigen Abschnitt wird hinsichtlich Problem \ref{prob:ffCCN}im Abschnitt \ref{abs_CNN_in_SQL} eine (objekt-) relationale Umsetzung der Vorwärtsrechnung für das tranierte Modell \ref{modell} zur Ziffernerkennung vorgestellt. Dies spiegelt zugleich das Hauptresultat dieser Arbeit wieder, welches schließlich im Abschnitt \ref{abs:CNN_eval} evaluiert wird. 
\section{Die Faltungsoperation in SQL}
\label{abs:conv_in_sql}
Die Faltung zweier zeitdiskrete Signale stellt die Kernoperation innerhalb von CNN dar. Sind die entsprechenden Signale zweidimensional wie in Problemstellung \ref{prob:conv_in_sql}, so muss die Matrixfaltung $X \ast K$ für $X \in \RR^{h \times b}$ und $K \in \RR^{k \times k}$ mithilfe des im Abschnitt \ref{abs:relation_intro} vorgestellten SQL-Kerns umgesetzt werden. Dazu werden in diesem Abschnitt drei Varianten vorgestellt, welche das Coordinate-Schema bzw. das Spaltenkompression-Schema zur Darstellung der Matrizen $X$ und $K$ nutzen. 
\subsection{Faltung mit Nachbarschaften}
\label{abs:naive_app}
Der erste Ansatz beruht auf den Nachbarschaftsbeziehungen der Pixel innerhalb der Matrix $X$, die durch die Faltung mit einem Kern $K$ mit den Abmessungen $k \times k$ gegeben sind. Dazu werden einige Bezeichnungen im Folgenden eingeführt. Seien $l=\lfloor k/2 \rfloor$ und die Mengen
\begin{align*}
    N:=\{(i,j) \; :\; 1 \leq i \leq b, 1 \leq j \leq h \}
\end{align*} 
sowie
\begin{align*}
    F:=\{(i,j) \; :\; -l \leq i \leq l, -l \leq j \leq l \}
\end{align*} 
gegeben, welche die Positionen der Matrizen $X$ und $K$ widerspiegeln. Hier wird wieder die spezielle Indizierung des Kerns $K$ wie in Bemerkung \ref{bem:K_conv_komp} genutzt. Nun kann für jeden Pixel $(i,j)$ von $X$ eine Umgebung $U(i,j)$  in Abhängigkeit von $F$ definiert werden, und zwar
\begin{equation}
    \label{eq:neighborhood}
    U(i,j):=\{(i', j') \; : \; (i'-i, j'-j) \in F \}.
\end{equation}
Die Menge $U(i,j)$ wird auch als Nachbarschaft des Pixels $(i,j)$ bezeichnet.
Die Matrixfaltung $Y= X \ast K$ lässt sich mit den Nachbarschaften (\ref{eq:neighborhood}) durch
\begin{equation}
    \label{eq:naive_approach}
    Y_{i,j}=\sum_{(i',j') \in U(i,j)} X_{i', j'} K_{i'-i, j'-j}, \; \; \forall i \in [h], \forall j \in [b]
\end{equation}
berechnen. Dabei wird $X$ außerhalb des Definitionsbereiches mit Nullen aufgefüllt, sodass das Ergebnis $Y$ wieder die gleichen Abmessungen wie $X$ besitzt.

Zur Umsetzung der Faltungsoperation sind also zunächst die Nachbarschaften für jeden Pixel von $X$ zu berechnen. In SQL kann dies mithilfe des kartesischem Produkts implementiert werden. Dazu bezeichnen $\mathbf{X}$ und $\mathbf{K}$ die Relation zur Darstellung der Matrizen $X$ und $K$ im Coordinate-Schema. Eine rein relationale Umsetzung von (\ref{eq:naive_approach}) ist durch die SQL-Anfrage \ref{sql:naive} gegeben. Zur Übersicht sind die Attributbezeichnungen groß geschrieben und die SQL-Klausel blau gekennzeichnet. 

\lstinputlisting[label=sql:naive, caption=SQL-Code zur Umsetzung der Faltung mit Nachbarschaften, language=SQL]{sql_code/neighborhood.sql}

In der Teilanfrage (Zeile 4-14) werden die Nachbarschaften aller Pixel in der temporären $\mathbf{KREUZ}$ Relation berechnet. Dabei wird die \textbf{BETWEEN}-Funktion zur kompakten Darstellung der Konstantenselektion bezüglich $l=\lfloor k/2 \rfloor$ genutzt. In den Zeilen 15-17 werden dann die Nachbarschaften über die entsprechenden Indizies der Filtermatrix verbunden und schließlich die \textbf{SUM}-Funktion genutzt, um das Faltungsergebnis zu berechnen. Dieser naive Ansatz nutzt keine lineare Algebra in Form von Matrixvektor- oder Matrixmatrixmultiplikation und ist hinsichtlich des Problems \ref{prob:conv_in_sql} schon für verhältnismäßig kleine Grauwertbilder ineffizient. Zu Erkennen ist dies in der Abbildung \ref{abb:laufzeit_naive}, bei der die Laufzeiten der SQL-Anfrage \ref{sql:naive} in Abhängigkeit von der Dimension $n$ für allgemeine Matrizen $X \in [0,1]^{n \times n}$ dargestellt ist.

TODO Grafik ergebnis erklären.

Eine Verbesserung der Laufzeiten kann mithilfe von Umsetzungstabellen, engl. \textit{Lookup tables}, erreicht werden. Da die Dimensionen aller vorkommenden Merkmalskarten und Kerne eines CNN von Anfang an durch die Wahl der Hyperparameter festgelegt werden, müssen die Nachbarschaften für die Faltung und das Pooling nur einmalig berechnet werden. Dies kann zudem vor der eigentlichen Erkennungsphase durchgeführt werden. So wird zwar der Speicheraufwand erhöht, aber der Zeitaufwand hinsichtlich der Faltungs- und Poolingoperation deutlich vermindert. Dazu werden pro Faltungs- und Poolingschicht jeweils eine Umsetzungstabelle \textbf{U} in der Form 
\begin{align*}
    \mathbf{U}( &\underline{i} \; \; \mathrm{int}, \\
    &\underline{j} \; \;\mathrm{int},\\
    &\underline{\text{id}} \; \; \mathrm{int}, \\
    &\text{istrich} \; \; \mathrm{int},\\
    &\text{jstrich}\; \; \mathrm{int})
\end{align*}
mit dem zusammengesetzten Schlüssel $(i,j,\text{id})$ benötigt. Hier werden für jeden Pixel $(i,j)$ die Nachbarpixel $(i', j') \in U$ mit einer entsprechenden Nummer $\text{id}$ hinterlegt. So wird die zeitintensive Berechnung der Nachbarschaften mit dem  kartesischen Produkt in der Anfrage \ref{sql:naive} umgangen. Die Laufzeiten dieser Verbesserung sind in Abbildung \ref{abb:laufzeit_naive_verb} dargestellt.

TODO Grafik ergebnis erklären.

\subsection{Faltung als Matrixvektorprodukt}
\label{abs:conv_using_sparse}
Zwei beliebige Funktionen $f,g: D \rightarrow \mathbb{R}$ mit endlichem Definitionsbereich $D$ können als zeitdiskrete Signale $f=(f_0, \ldots, f_{n-1})^T \in \mathbb{R}^{n}$ und $g=(g_0, \ldots, g_{n-1})^T \in \mathbb{R}^{n}$ aufgefasst werden. %Durch das Fortsetzen mit Nullen besitzen die Vektoren $f$ und $g$ die gleiche Länge. 
Die diskrete Faltung dieser eindimensionalen Signale wird im Folgenden erklärt.

\begin{defi}
    \label{def:cycconv}
    Das Faltungsergebnis $y \in \RR^{n}$ zweier zeitdiskreter Signale $f \in \RR^n$ und $g \in \RR^n$ ist durch
    \begin{equation}
        y_k:=\sum_{j=0}^{k} f_j g_{k-j}, \; \; 0 \leq k \leq n-1
    \end{equation}
    definiert.
\end{defi}
In diesem Fall kann die diskrete Faltung von $f$ und $g$ als Matrixvektorprodukt mit Toeplitz-Matrizen formuliert werden. 

\begin{defi}[Toeplitz-Matrix, Zyklische Matrix]
    \label{def:toeplitzM}
    Eine diagonalkonstante Matrix $A \in \RR^{n \times n}$ der Gestalt
    \begin{equation*}
    A=
    \begin{pmatrix}
        a_0 & a_{-1} &a_{-2} &\ldots &\ldots &a_{-(n-1)} \\ 
        a_1 & a_0 &a_{-1} &\ddots & &\vdots \\
        a_2 & a_1 &\ddots &\ddots &\ddots &\vdots\\
        \vdots & \ddots &\ddots &\ddots &a_{-1} &a_{-2}\\
        \vdots & &\ddots &a_1 &a_0 &a_{-1} \\
        a_{n-1} &\ldots &\ldots &a_{2} &a_{1} &a_0
    \end{pmatrix}
\end{equation*}
    wird Toeplitz\footnote{Otto Toeplitz 1881-1940}-Matrix genannt. Hierbei gilt $A_{i,j}=A_{i+1,j+1}=a_{i-j}$ für alle Indizies $1 \leq i, j \leq n$. Eine quadratische Toeplitzmatrix ist damit durch ihre erste Zeile und Spalte eindeutig bestimmt. Für den Spezialfall $a_i=a_{-(n-i)}=a_{i-n}$ für alle $1 \leq i \leq n-1$ wird $A$ zyklische Matrix genannt.
\end{defi}

%\begin{defi}[Zyklische Matrix, vgl. Gray\cite{gray2006toeplitz}]
  %  \label{def:zykM}
   % Eine quadratische Matrix heißt zyklisch im Vektor $a=(a_0, \ldots, a_{n-1})^T \in \RR^n$, wenn sie die Gesatlt
    %\begin{equation*}
        %\mathrm{zyk}(a):=
        %\begin{pmatrix}
            %a_0 & a_{n-1} &a_{n-2} &\ldots &a_1 \\ 
            %a_1 & a_0 &a_{n-1} & \ldots &a_2 \\
            %a_2 & a_1 &a_0 & \ldots &a_3 \\
            % &\ddots &\ddots &\ddots & \\
            %a_{n-1} &a_{n-2} &a_{n-3} &\ldots &a_0
        %\end{pmatrix}
    %\end{equation*}
   % besitzt.
%\end{defi}    
    
Für ein zeitdiskrete Signal $g \in \mathbb{R}^{n}$ wird die Toeplitz-Matrix 
\begin{equation*} 
    G_n=\begin{pmatrix}
        g_0 & 0 &0 &\ldots &\ldots &0 \\ 
        g_1 & g_0 &0 &\ddots & &\vdots \\
        g_2 & g_1 &\ddots &\ddots &\ddots &\vdots\\
        \vdots & \ddots &\ddots &\ddots &0 &0\\
        \vdots & &\ddots &g_1 &g_0 &0 \\
        g_{n-1} &\ldots &\ldots &g_{2} &g_{1} &g_0
    \end{pmatrix}
\end{equation*}
konstruiert. Sei ein zeitdiskretes Signal $f \in \RR^{n}$ gegeben und der Vektor $y \in \RR^n$ durch
\begin{equation*}
    y:=G_n f =\begin{pmatrix}
        g_0 & 0 &0 &\ldots &\ldots &0 \\ 
        g_1 & g_0 &0 &\ddots & &\vdots \\
        g_2 & g_1 &\ddots &\ddots &\ddots &\vdots\\
        \vdots & \ddots &\ddots &\ddots &0 &0\\
        \vdots & &\ddots &g_1 &g_0 &0 \\
        g_{n-1} &\ldots &\ldots &g_{2} &g_{1} &g_0
    \end{pmatrix}
    \begin{pmatrix}
        f_0 \\
        f_1 \\
        f_2 \\
        \vdots \\
        \vdots \\
        f_{n-1}
    \end{pmatrix} \\
    = \begin{pmatrix}
        g_0 f_0 \\
        g_1 f_0+ g_0 f_1 \\
        \sum_{j=0}^2 f_j g_{2-j}  \\
        \vdots \\
        \vdots \\
        \sum_{j=0}^{n-1} f_j g_{n-1-j} 
    \end{pmatrix}
\end{equation*}
mit den Einträgen 
\begin{equation*}
   y_k=\sum_{j=0}^k f_j g_{k-j}, \; \; 0 \leq k \leq n-1
\end{equation*}
gegeben.
Dann spiegelt $y$ das Ergebnis der eindimensionalen diskreten Faltung von $f$ und $g$ wider. Die Faltung zweidimensionaler Signale kann mithilfe von zyklischen Blockmatrizen dargestellt werden.
    %Matrix im Vektor $f$. Sei weiter $g \in \mathbb{R}^{n}$. Dann lässt sich mit
%\begin{equation*}
 %       (F g)_k=\sum_{j=0}^{n-1}  f_{k-j} g_j,  \; \; k=0, \ldots, n-1
  %  \end{equation*}
   % die diskrete Faltung von $f$ und $g$ darstellen. Dabei werden Indizies außerhalb von $0, \ldots, n-1$ zyklisch durch Modulo-Rechnung ($\mathrm{mod} \; n)$ in den gültigen Indexbereich abgebildet. Zyklische Matrizen aus Definition \ref{def:zykM} stellen Spezialfälle von Toeplitz-Matrizen dar.
\begin{defi}
    \label{def:double_circ}
    Eine Blockmatrix $A \in \RR^{n^2 \times n^2}$ bestehend aus Blockmatrizen $B_{i,j} \in \RR^{n \times n}$ heißt zyklische Blockmatrix, genau dann wenn die Matrizen $B_{i,j}$ für alle $ 1 \leq i, j \leq n$ zyklisch im Sinne von Definietion \ref{def:toeplitzM} sind.
\end{defi}

Die Konstruktion solcher zyklischen Blockmatrizen soll im Folgenden beleuchtet werden. Dazu  seien für $h=b=n$ die Matrizen $X \in \RR^{n \times n}$ und $K \in \RR^{k \times k}$ einer Faltungschicht gegeben. Zunächst wird der Kern $K$ mithilfe des zero paddings ebenfalls in eine $n \times n$-Matrix eingebettet. Dazu wird der Kern ja nach der gewünschten Größe des Faltungsergebnis von unten und von rechts mit Nullen aufgefüllt, siehe dazu Beispiel \ref{bsp:Kzeropad}.
Weiter bezeichne $\mathrm{vec}(X)$ die Transformation der Matrix $X$ in einen Vektor der Länge $n^2$, indem die Spalten von $X$ untereinander geschrieben werden, ähnlich wie bei der Flatten-Funktion \ref{def:flatten} aus Kapitel \ref{kap:CNN}. Das folgende Lemma liefert die Darstellung der Faltungsoperation als Matrixvektorprodukt.

\begin{lem}[vgl. Jain\cite{jain}, Goodfellow\cite{Goodfellow-et-al-2016}]
    Für $K \in \RR^{n \times n}$ wird die zyklische Blockmatrix $A \in \RR^{n \times n}$ als
    \begin{equation*}
        A=\begin{bmatrix}
            \mathrm{zyk}(K_{1,:}) &\mathrm{zyk}(K_{2,:}) &\ldots &\mathrm{zyk}(K_{n,:}) \\
            \mathrm{zyk}(K_{n,:}) &\mathrm{zyk}(K_{1,:}) &\ldots & \; \; \;\mathrm{zyk}(K_{n-1,:})\\
            \vdots &\vdots &\ddots &\vdots\\
            \mathrm{zyk}(K_{2,:}) &\mathrm{zyk}(K_{3,:}) &\ldots &\mathrm{zyk}(K_{1,:})
        \end{bmatrix}
    \end{equation*}
    gegeben. Dann entspricht $Y=A \mathrm{vec}(X)$ dem Ergebnis der Matrixfaltung $X \ast K$. Die Matrix $A$ ist dünnbesetzt. 
\end{lem}

\begin{bsp}
    \label{bsp:Kzeropad}
    TODO
\end{bsp}

\subsection{Diskrete Fourier-Transformation}
Die Diskrete Fourier\footnote{Jean Baptiste Joseph Fourier 1786-1830}-Transformation ist eine Methode aus dem Bereich der Fourier-Analysis. Dabei werden zeitdiskrete endliche Signale auf sogenannte diskrete, periodische Frequenzspektren abgebildet. In diesem Kontext wird zwischen Zeitbereich und Frequenzbereich unterschieden.

\begin{defi}[Diskrete Fourier-Transformation]
    \label{def:dft}
    Im Zeitbereich sei ein diskretes Signal $x=(x_0, \ldots, x_{n-1})^T \in \RR^n$ gegeben. Dann wird mit $\hat{x}=(\hat{x}_0, \ldots, \hat{x}_{n-1}) \in \mathbb{C}^n$ das Ergebnis der diskreten Fourier-Transformation, kurz $\hat{x}=\mathrm{DFT}(x)$, im Frequenzbereich bezeichnet. Die sogenannten Fourier-Koeffizienten sind als 
    \begin{equation*}
        \hat{x}_k:=\sum_{j=0}^{n-1} \mathrm{e}^{- \frac{2 \pi i}{n} j k} \cdot x_k
    \end{equation*}
    für $0 \leq k \leq n-1$ definiert.
\end{defi}
Mit der inversen Fourier-Transformation kann aus dem Signal im Frequenzbereich das Signal im Zeitbereich rekonstruiert werden. Damit ist es möglich, Signale im Frequenzbereich zu manipulieren und zwischen Zeit- und Frequenzbereich beliebig zu wechseln.
\begin{defi}[Inverse Diskrete Fourier-Transformation]
    Sei $\hat{x}=(\hat{x}_0, \ldots, \hat{x}_{n-1}) \in \mathbb{C}^n$ das Ergebnis der diskreten Fourier-Transformation von $x \in \RR^n$. Mit 
    \begin{equation*}
        x_k:= \frac{1}{n} \sum_{j=0}^{n-1} \mathrm{e}^{\frac{2 \pi i}{n} j k} \cdot \hat{x}_k, \; \; 0 \leq k \leq n-1
    \end{equation*}
    lassen sich die Einträge des Vektors $x$ rekonstruieren. Diese Transformation wird inverse diskrete Fourier-Transformation, kurz $x=\mathrm{iDFT}(\hat{x})$, genannt.
\end{defi}
Die diskrete Fourier-Transformation aus Definition \ref{def:dft} lässt sich in ein Matrixvektorprodukt $\hat{x}=Fx$ überführen, wobei $F \in \mathbb{C}^{n \times n}$ eine quadratische Matrix mit den Einträgen
\begin{equation}
    \label{eq:FM}
    F_{k,j}= \mathrm{e}^{- \frac{2 \pi i}{n} j k}, \; \; 0 \leq k, j \leq n-1
\end{equation}
ist. Diese Matrix wird Fourier-Matrix genannt und deren Einträge als \textit{Twiddle}-Faktoren bezeichnet. Wird ein zweidimensionales diskretes Signal in Form einer Matrix $X \in \RR^{n}$ betrachtet, lässt sich die zweidimensionale diskrete Fourier-Transformation definieren. 
\begin{defi}
    Sei $X \in \RR^{n \times n}$ gegeben. Die Koeffizienten der zweidimensionalen diskreten Fourier-Transformation, kurz $\hat{X}=2\mathrm{DFT}(X)$, sind als
    \begin{align*}
        \hat{X}_{u,v}:&= \sum_{l=0}^{n-1} \sum_{j=0}^{n-1} X_{l,j} \cdot \mathrm{e}^{\frac{2 \pi i}{n} -(lu+jv)} \\
        &=\sum_{l=0}^{n-1} \mathrm{e}^{-\frac{2 \pi i}{n} l u} \left(\sum_{j=0}^{n-1} X_{l,j} \cdot \mathrm{e}^{-\frac{2 \pi i}{n} j v}\right), \; \; 0 \leq u, v \leq n-1
    \end{align*}
    definiert.
\end{defi}
Die zweidimensionale diskrete Fourier-Transformation ist als Hintereinanderausführung von zwei eindimensionalen Fourier-Transformationen, vgl. Definition \ref{def:dft}, zu verstehen. Zuerst wird die $\mathrm{DFT}$ der Zeilen und anschließend die $\mathrm{DFT}$ der Spalten von $X$ berechnet. So lässt sich $\hat{X}=\mathrm{2DFT}(X)$ als Matrixmatrixprodukt $\hat{X}=FXF^T$ mit der Matrix $F$ aus (\ref{eq:FM}) darstellen.

Zwischen der zyklischen Faltung \ref{def:cycconv} und der diskreten Fourier-Transformation \ref{def:dft} besteht ein fundamentaler Zusammenhang, und zwar das Faltungstheorem. Eine Version davon wird im weiteren Verlauf dieser Arbeit genutzt, um die Matrixfaltung, vgl. Definition \ref{def:matrix_faltung}, mithilfe von Fourier-Transformationen zu berechnen.

\begin{satz}
    Seine Vektoren $f,g \in \RR^{n}$ gegeben und $y:= f \ast g$ das Ergebnis der zyklischen Faltung. Dann gilt
    \begin{equation}
        y=\mathrm{iDFT}\left(\mathrm{DFT}(f) \odot \mathrm{DFT}(g) \right).
    \end{equation}
    Dabei bezeichne $\odot$ die elementweise Multiplikation der Einträge von den beteiligten Vektoren.
\end{satz}
\begin{bem}[Zyklisches Faltungstheorem]
    Seien die Matrizen $X \in \RR^{n \times n}$ und $K \in \RR^{k \times k}$ mit ungeradem $k$ gegeben.
\end{bem}
\label{abs:FFN_in_sql}
\section{Datenbankgestützte Vorwärtsrechnung}
\label{abs_CNN_in_SQL}
\section{Evalution}
\label{abs:CNN_eval}